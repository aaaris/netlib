{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.date.to-string.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nvar Source = require(\"./Source\");\n\nvar streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\n\nvar streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\n\nvar streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nvar mapToBufferedMap = function mapToBufferedMap(map) {\n  if (_typeof(map) !== \"object\" || !map) return map;\n  var bufferedMap = Object.assign({}, map);\n\n  if (map.mappings) {\n    bufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n  }\n\n  if (map.sourcesContent) {\n    bufferedMap.sourcesContent = map.sourcesContent.map(function (str) {\n      return str && Buffer.from(str, \"utf-8\");\n    });\n  }\n\n  return bufferedMap;\n};\n\nvar bufferedMapToMap = function bufferedMapToMap(bufferedMap) {\n  if (_typeof(bufferedMap) !== \"object\" || !bufferedMap) return bufferedMap;\n  var map = Object.assign({}, bufferedMap);\n\n  if (bufferedMap.mappings) {\n    map.mappings = bufferedMap.mappings.toString(\"utf-8\");\n  }\n\n  if (bufferedMap.sourcesContent) {\n    map.sourcesContent = bufferedMap.sourcesContent.map(function (buffer) {\n      return buffer && buffer.toString(\"utf-8\");\n    });\n  }\n\n  return map;\n};\n\nvar CachedSource = /*#__PURE__*/function (_Source) {\n  _inherits(CachedSource, _Source);\n\n  var _super = _createSuper(CachedSource);\n\n  function CachedSource(source, cachedData) {\n    var _this;\n\n    _classCallCheck(this, CachedSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._cachedSourceType = cachedData ? cachedData.source : undefined;\n    _this._cachedSource = undefined;\n    _this._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n    _this._cachedSize = cachedData ? cachedData.size : undefined;\n    _this._cachedMaps = cachedData ? cachedData.maps : new Map();\n    _this._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n    return _this;\n  }\n\n  _createClass(CachedSource, [{\n    key: \"getCachedData\",\n    value: function getCachedData() {\n      var bufferedMaps = new Map();\n\n      var _iterator = _createForOfIteratorHelper(this._cachedMaps),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          var cacheEntry = pair[1];\n\n          if (cacheEntry.bufferedMap === undefined) {\n            cacheEntry.bufferedMap = mapToBufferedMap(this._getMapFromCacheEntry(cacheEntry));\n          }\n\n          bufferedMaps.set(pair[0], {\n            map: undefined,\n            bufferedMap: cacheEntry.bufferedMap\n          });\n        } // We don't want to cache strings\n        // So if we have a caches sources\n        // create a buffer from it and only store\n        // if it was a Buffer or string\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this._cachedSource) {\n        this.buffer();\n      }\n\n      return {\n        buffer: this._cachedBuffer,\n        source: this._cachedSourceType !== undefined ? this._cachedSourceType : typeof this._cachedSource === \"string\" ? true : Buffer.isBuffer(this._cachedSource) ? false : undefined,\n        size: this._cachedSize,\n        maps: bufferedMaps,\n        hash: this._cachedHashUpdate\n      };\n    }\n  }, {\n    key: \"originalLazy\",\n    value: function originalLazy() {\n      return this._source;\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      if (typeof this._source === \"function\") this._source = this._source();\n      return this._source;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      var source = this._getCachedSource();\n\n      if (source !== undefined) return source;\n      return this._cachedSource = this.original().source();\n    }\n  }, {\n    key: \"_getMapFromCacheEntry\",\n    value: function _getMapFromCacheEntry(cacheEntry) {\n      if (cacheEntry.map !== undefined) {\n        return cacheEntry.map;\n      } else if (cacheEntry.bufferedMap !== undefined) {\n        return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);\n      }\n    }\n  }, {\n    key: \"_getCachedSource\",\n    value: function _getCachedSource() {\n      if (this._cachedSource !== undefined) return this._cachedSource;\n\n      if (this._cachedBuffer && this._cachedSourceType !== undefined) {\n        return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString(\"utf-8\") : this._cachedBuffer;\n      }\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      if (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\n      if (this._cachedSource !== undefined) {\n        if (Buffer.isBuffer(this._cachedSource)) {\n          return this._cachedBuffer = this._cachedSource;\n        }\n\n        return this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\");\n      }\n\n      if (typeof this.original().buffer === \"function\") {\n        return this._cachedBuffer = this.original().buffer();\n      }\n\n      var bufferOrString = this.source();\n\n      if (Buffer.isBuffer(bufferOrString)) {\n        return this._cachedBuffer = bufferOrString;\n      }\n\n      return this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\");\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      if (this._cachedSize !== undefined) return this._cachedSize;\n\n      if (this._cachedBuffer !== undefined) {\n        return this._cachedSize = this._cachedBuffer.length;\n      }\n\n      var source = this._getCachedSource();\n\n      if (source !== undefined) {\n        return this._cachedSize = Buffer.byteLength(source);\n      }\n\n      return this._cachedSize = this.original().size();\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      var key = options ? JSON.stringify(options) : \"{}\";\n\n      var cacheEntry = this._cachedMaps.get(key); // Look for a cached map\n\n\n      if (cacheEntry !== undefined) {\n        // We have a cached map in some representation\n        var _map = this._getMapFromCacheEntry(cacheEntry); // Either get the cached source or compute it\n\n\n        return {\n          source: this.source(),\n          map: _map\n        };\n      } // Look for a cached source\n\n\n      var source = this._getCachedSource(); // Compute the map\n\n\n      var map;\n\n      if (source !== undefined) {\n        map = this.original().map(options);\n      } else {\n        // Compute the source and map together.\n        var sourceAndMap = this.original().sourceAndMap(options);\n        source = sourceAndMap.source;\n        map = sourceAndMap.map;\n        this._cachedSource = source;\n      }\n\n      this._cachedMaps.set(key, {\n        map: map,\n        bufferedMap: undefined\n      });\n\n      return {\n        source: source,\n        map: map\n      };\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      var key = options ? JSON.stringify(options) : \"{}\";\n\n      if (this._cachedMaps.has(key) && (this._cachedBuffer !== undefined || this._cachedSource !== undefined)) {\n        var _this$sourceAndMap = this.sourceAndMap(options),\n            _source = _this$sourceAndMap.source,\n            _map2 = _this$sourceAndMap.map;\n\n        if (_map2) {\n          return streamChunksOfSourceMap(_source, _map2, onChunk, onSource, onName, !!(options && options.finalSource), true);\n        } else {\n          return streamChunksOfRawSource(_source, onChunk, onSource, onName, !!(options && options.finalSource));\n        }\n      }\n\n      var _streamAndGetSourceAn = streamAndGetSourceAndMap(this.original(), options, onChunk, onSource, onName),\n          result = _streamAndGetSourceAn.result,\n          source = _streamAndGetSourceAn.source,\n          map = _streamAndGetSourceAn.map;\n\n      this._cachedSource = source;\n\n      this._cachedMaps.set(key, {\n        map: map,\n        bufferedMap: undefined\n      });\n\n      return result;\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      var key = options ? JSON.stringify(options) : \"{}\";\n\n      var cacheEntry = this._cachedMaps.get(key);\n\n      if (cacheEntry !== undefined) {\n        return this._getMapFromCacheEntry(cacheEntry);\n      }\n\n      var map = this.original().map(options);\n\n      this._cachedMaps.set(key, {\n        map: map,\n        bufferedMap: undefined\n      });\n\n      return map;\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (this._cachedHashUpdate !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(this._cachedHashUpdate),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var item = _step2.value;\n            hash.update(item);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return;\n      }\n\n      var _update = [];\n      var currentString = undefined;\n      var tracker = {\n        update: function update(item) {\n          if (typeof item === \"string\" && item.length < 10240) {\n            if (currentString === undefined) {\n              currentString = item;\n            } else {\n              currentString += item;\n\n              if (currentString.length > 102400) {\n                _update.push(Buffer.from(currentString));\n\n                currentString = undefined;\n              }\n            }\n          } else {\n            if (currentString !== undefined) {\n              _update.push(Buffer.from(currentString));\n\n              currentString = undefined;\n            }\n\n            _update.push(item);\n          }\n        }\n      };\n      this.original().updateHash(tracker);\n\n      if (currentString !== undefined) {\n        _update.push(Buffer.from(currentString));\n      }\n\n      for (var _i = 0, _update2 = _update; _i < _update2.length; _i++) {\n        var _item = _update2[_i];\n        hash.update(_item);\n      }\n\n      this._cachedHashUpdate = _update;\n    }\n  }]);\n\n  return CachedSource;\n}(Source);\n\nmodule.exports = CachedSource;","map":{"version":3,"names":["Source","require","streamChunksOfSourceMap","streamChunksOfRawSource","streamAndGetSourceAndMap","mapToBufferedMap","map","bufferedMap","Object","assign","mappings","Buffer","from","sourcesContent","str","bufferedMapToMap","toString","buffer","CachedSource","source","cachedData","_source","_cachedSourceType","undefined","_cachedSource","_cachedBuffer","_cachedSize","size","_cachedMaps","maps","Map","_cachedHashUpdate","hash","bufferedMaps","pair","cacheEntry","_getMapFromCacheEntry","set","isBuffer","_getCachedSource","original","bufferOrString","length","byteLength","options","key","JSON","stringify","get","sourceAndMap","onChunk","onSource","onName","has","finalSource","result","item","update","currentString","tracker","push","updateHash","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/webpack-sources/lib/CachedSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\nconst streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nconst mapToBufferedMap = map => {\n\tif (typeof map !== \"object\" || !map) return map;\n\tconst bufferedMap = Object.assign({}, map);\n\tif (map.mappings) {\n\t\tbufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n\t}\n\tif (map.sourcesContent) {\n\t\tbufferedMap.sourcesContent = map.sourcesContent.map(\n\t\t\tstr => str && Buffer.from(str, \"utf-8\")\n\t\t);\n\t}\n\treturn bufferedMap;\n};\n\nconst bufferedMapToMap = bufferedMap => {\n\tif (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\n\tconst map = Object.assign({}, bufferedMap);\n\tif (bufferedMap.mappings) {\n\t\tmap.mappings = bufferedMap.mappings.toString(\"utf-8\");\n\t}\n\tif (bufferedMap.sourcesContent) {\n\t\tmap.sourcesContent = bufferedMap.sourcesContent.map(\n\t\t\tbuffer => buffer && buffer.toString(\"utf-8\")\n\t\t);\n\t}\n\treturn map;\n};\n\nclass CachedSource extends Source {\n\tconstructor(source, cachedData) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._cachedSourceType = cachedData ? cachedData.source : undefined;\n\t\tthis._cachedSource = undefined;\n\t\tthis._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n\t\tthis._cachedSize = cachedData ? cachedData.size : undefined;\n\t\tthis._cachedMaps = cachedData ? cachedData.maps : new Map();\n\t\tthis._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n\t}\n\n\tgetCachedData() {\n\t\tconst bufferedMaps = new Map();\n\t\tfor (const pair of this._cachedMaps) {\n\t\t\tlet cacheEntry = pair[1];\n\t\t\tif (cacheEntry.bufferedMap === undefined) {\n\t\t\t\tcacheEntry.bufferedMap = mapToBufferedMap(\n\t\t\t\t\tthis._getMapFromCacheEntry(cacheEntry)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbufferedMaps.set(pair[0], {\n\t\t\t\tmap: undefined,\n\t\t\t\tbufferedMap: cacheEntry.bufferedMap\n\t\t\t});\n\t\t}\n\t\t// We don't want to cache strings\n\t\t// So if we have a caches sources\n\t\t// create a buffer from it and only store\n\t\t// if it was a Buffer or string\n\t\tif (this._cachedSource) {\n\t\t\tthis.buffer();\n\t\t}\n\t\treturn {\n\t\t\tbuffer: this._cachedBuffer,\n\t\t\tsource:\n\t\t\t\tthis._cachedSourceType !== undefined\n\t\t\t\t\t? this._cachedSourceType\n\t\t\t\t\t: typeof this._cachedSource === \"string\"\n\t\t\t\t\t? true\n\t\t\t\t\t: Buffer.isBuffer(this._cachedSource)\n\t\t\t\t\t? false\n\t\t\t\t\t: undefined,\n\t\t\tsize: this._cachedSize,\n\t\t\tmaps: bufferedMaps,\n\t\t\thash: this._cachedHashUpdate\n\t\t};\n\t}\n\n\toriginalLazy() {\n\t\treturn this._source;\n\t}\n\n\toriginal() {\n\t\tif (typeof this._source === \"function\") this._source = this._source();\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) return source;\n\t\treturn (this._cachedSource = this.original().source());\n\t}\n\n\t_getMapFromCacheEntry(cacheEntry) {\n\t\tif (cacheEntry.map !== undefined) {\n\t\t\treturn cacheEntry.map;\n\t\t} else if (cacheEntry.bufferedMap !== undefined) {\n\t\t\treturn (cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap));\n\t\t}\n\t}\n\n\t_getCachedSource() {\n\t\tif (this._cachedSource !== undefined) return this._cachedSource;\n\t\tif (this._cachedBuffer && this._cachedSourceType !== undefined) {\n\t\t\treturn (this._cachedSource = this._cachedSourceType\n\t\t\t\t? this._cachedBuffer.toString(\"utf-8\")\n\t\t\t\t: this._cachedBuffer);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\t\tif (this._cachedSource !== undefined) {\n\t\t\tif (Buffer.isBuffer(this._cachedSource)) {\n\t\t\t\treturn (this._cachedBuffer = this._cachedSource);\n\t\t\t}\n\t\t\treturn (this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\"));\n\t\t}\n\t\tif (typeof this.original().buffer === \"function\") {\n\t\t\treturn (this._cachedBuffer = this.original().buffer());\n\t\t}\n\t\tconst bufferOrString = this.source();\n\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\treturn (this._cachedBuffer = bufferOrString);\n\t\t}\n\t\treturn (this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\"));\n\t}\n\n\tsize() {\n\t\tif (this._cachedSize !== undefined) return this._cachedSize;\n\t\tif (this._cachedBuffer !== undefined) {\n\t\t\treturn (this._cachedSize = this._cachedBuffer.length);\n\t\t}\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) {\n\t\t\treturn (this._cachedSize = Buffer.byteLength(source));\n\t\t}\n\t\treturn (this._cachedSize = this.original().size());\n\t}\n\n\tsourceAndMap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\t// Look for a cached map\n\t\tif (cacheEntry !== undefined) {\n\t\t\t// We have a cached map in some representation\n\t\t\tconst map = this._getMapFromCacheEntry(cacheEntry);\n\t\t\t// Either get the cached source or compute it\n\t\t\treturn { source: this.source(), map };\n\t\t}\n\t\t// Look for a cached source\n\t\tlet source = this._getCachedSource();\n\t\t// Compute the map\n\t\tlet map;\n\t\tif (source !== undefined) {\n\t\t\tmap = this.original().map(options);\n\t\t} else {\n\t\t\t// Compute the source and map together.\n\t\t\tconst sourceAndMap = this.original().sourceAndMap(options);\n\t\t\tsource = sourceAndMap.source;\n\t\t\tmap = sourceAndMap.map;\n\t\t\tthis._cachedSource = source;\n\t\t}\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn { source, map };\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tif (\n\t\t\tthis._cachedMaps.has(key) &&\n\t\t\t(this._cachedBuffer !== undefined || this._cachedSource !== undefined)\n\t\t) {\n\t\t\tconst { source, map } = this.sourceAndMap(options);\n\t\t\tif (map) {\n\t\t\t\treturn streamChunksOfSourceMap(\n\t\t\t\t\tsource,\n\t\t\t\t\tmap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn streamChunksOfRawSource(\n\t\t\t\t\tsource,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst { result, source, map } = streamAndGetSourceAndMap(\n\t\t\tthis.original(),\n\t\t\toptions,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\tthis._cachedSource = source;\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn result;\n\t}\n\n\tmap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn this._getMapFromCacheEntry(cacheEntry);\n\t\t}\n\t\tconst map = this.original().map(options);\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn map;\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._cachedHashUpdate !== undefined) {\n\t\t\tfor (const item of this._cachedHashUpdate) hash.update(item);\n\t\t\treturn;\n\t\t}\n\t\tconst update = [];\n\t\tlet currentString = undefined;\n\t\tconst tracker = {\n\t\t\tupdate: item => {\n\t\t\t\tif (typeof item === \"string\" && item.length < 10240) {\n\t\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\t\tcurrentString = item;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentString += item;\n\t\t\t\t\t\tif (currentString.length > 102400) {\n\t\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tupdate.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.original().updateHash(tracker);\n\t\tif (currentString !== undefined) {\n\t\t\tupdate.push(Buffer.from(currentString));\n\t\t}\n\t\tfor (const item of update) hash.update(item);\n\t\tthis._cachedHashUpdate = update;\n\t}\n}\n\nmodule.exports = CachedSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}