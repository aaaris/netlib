{"ast":null,"code":"\"use strict\";\n/** @typedef {import(\"source-map\").RawSourceMap} RawSourceMap */\n\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/** @typedef {import(\"./index.js\").Input} Input */\n\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\n\nvar _defineProperty = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/defineProperty.js\")[\"default\"];\n\nvar _objectSpread = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/objectSpread2.js\")[\"default\"];\n\nvar _asyncToGenerator = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/asyncToGenerator.js\")[\"default\"];\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.number.is-integer.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nrequire(\"core-js/modules/es.array.every.js\");\n\nrequire(\"core-js/modules/es.array.fill.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.array.for-each.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.object.entries.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar notSettled = Symbol(\"not-settled\");\n/**\n * @template T\n * @typedef {() => Promise<T>} Task\n */\n\n/**\n * Run tasks with limited concurency.\n * @template T\n * @param {number} limit - Limit of tasks that run at once.\n * @param {Task<T>[]} tasks - List of tasks to run.\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\n */\n\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(\"Expected `limit` to be a finite number > 0, got `\".concat(limit, \"` (\").concat(_typeof(limit), \")\"));\n  }\n\n  if (!Array.isArray(tasks) || !tasks.every(function (task) {\n    return typeof task === \"function\";\n  })) {\n    throw new TypeError(\"Expected `tasks` to be a list of functions returning a promise\");\n  }\n\n  return new Promise(function (resolve, reject) {\n    var result = Array(tasks.length).fill(notSettled);\n    var entries = tasks.entries();\n\n    var next = function next() {\n      var _entries$next = entries.next(),\n          done = _entries$next.done,\n          value = _entries$next.value;\n\n      if (done) {\n        var isLast = !result.includes(notSettled);\n        if (isLast) resolve(\n        /** @type{T[]} **/\n        result);\n        return;\n      }\n\n      var _value = _slicedToArray(value, 2),\n          index = _value[0],\n          task = _value[1];\n      /**\n       * @param {T} x\n       */\n\n\n      var onFulfilled = function onFulfilled(x) {\n        result[index] = x;\n        next();\n      };\n\n      task().then(onFulfilled, reject);\n    };\n\n    Array(limit).fill(0).forEach(next);\n  });\n}\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nfunction terserMinify(_x, _x2, _x3, _x4) {\n  return _terserMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\n\n\nfunction _terserMinify() {\n  _terserMinify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(input, sourceMap, minimizerOptions, extractComments) {\n    var isObject, buildComments, buildTerserOptions, _require, minify, terserOptions, extractedComments, _Object$entries, _Object$entries2, _Object$entries2$, filename, code, result;\n\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            /**\n             * @param {any} value\n             * @returns {boolean}\n             */\n            isObject = function isObject(value) {\n              var type = _typeof(value);\n\n              return value != null && (type === \"object\" || type === \"function\");\n            };\n            /**\n             * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\n             * @param {ExtractedComments} extractedComments\n             * @returns {ExtractCommentsFunction}\n             */\n\n\n            buildComments = function buildComments(terserOptions, extractedComments) {\n              /** @type {{ [index: string]: ExtractCommentsCondition }} */\n              var condition = {};\n              var comments;\n\n              if (terserOptions.format) {\n                comments = terserOptions.format.comments;\n              } else if (terserOptions.output) {\n                comments = terserOptions.output.comments;\n              }\n\n              condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n              if (typeof extractComments === \"boolean\" && extractComments) {\n                condition.extract = \"some\";\n              } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n                condition.extract = extractComments;\n              } else if (typeof extractComments === \"function\") {\n                condition.extract = extractComments;\n              } else if (extractComments && isObject(extractComments)) {\n                condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n              } else {\n                // No extract\n                // Preserve using \"commentsOpts\" or \"some\"\n                condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n                condition.extract = false;\n              } // Ensure that both conditions are functions\n\n\n              [\"preserve\", \"extract\"].forEach(function (key) {\n                /** @type {undefined | string} */\n                var regexStr;\n                /** @type {undefined | RegExp} */\n\n                var regex;\n\n                switch (_typeof(condition[key])) {\n                  case \"boolean\":\n                    condition[key] = condition[key] ? function () {\n                      return true;\n                    } : function () {\n                      return false;\n                    };\n                    break;\n\n                  case \"function\":\n                    break;\n\n                  case \"string\":\n                    if (condition[key] === \"all\") {\n                      condition[key] = function () {\n                        return true;\n                      };\n\n                      break;\n                    }\n\n                    if (condition[key] === \"some\") {\n                      condition[key] =\n                      /** @type {ExtractCommentsFunction} */\n                      function (astNode, comment) {\n                        return (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n                      };\n\n                      break;\n                    }\n\n                    regexStr =\n                    /** @type {string} */\n                    condition[key];\n\n                    condition[key] =\n                    /** @type {ExtractCommentsFunction} */\n                    function (astNode, comment) {\n                      return new RegExp(\n                      /** @type {string} */\n                      regexStr).test(comment.value);\n                    };\n\n                    break;\n\n                  default:\n                    regex =\n                    /** @type {RegExp} */\n                    condition[key];\n\n                    condition[key] =\n                    /** @type {ExtractCommentsFunction} */\n                    function (astNode, comment) {\n                      return (\n                        /** @type {RegExp} */\n                        regex.test(comment.value)\n                      );\n                    };\n\n                }\n              }); // Redefine the comments function to extract and preserve\n              // comments according to the two conditions\n\n              return function (astNode, comment) {\n                if (\n                /** @type {{ extract: ExtractCommentsFunction }} */\n                condition.extract(astNode, comment)) {\n                  var commentText = comment.type === \"comment2\" ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value); // Don't include duplicate comments\n\n                  if (!extractedComments.includes(commentText)) {\n                    extractedComments.push(commentText);\n                  }\n                }\n\n                return (\n                  /** @type {{ preserve: ExtractCommentsFunction }} */\n                  condition.preserve(astNode, comment)\n                );\n              };\n            };\n            /**\n             * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\n             * @returns {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\n             */\n\n\n            buildTerserOptions = function buildTerserOptions() {\n              var terserOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n              return _objectSpread(_objectSpread(_objectSpread({}, terserOptions), {}, {\n                compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress : _objectSpread({}, terserOptions.compress),\n                // ecma: terserOptions.ecma,\n                // ie8: terserOptions.ie8,\n                // keep_classnames: terserOptions.keep_classnames,\n                // keep_fnames: terserOptions.keep_fnames,\n                mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : _objectSpread({}, terserOptions.mangle)\n              }, terserOptions.format ? {\n                format: _objectSpread({\n                  beautify: false\n                }, terserOptions.format)\n              } : {\n                output: _objectSpread({\n                  beautify: false\n                }, terserOptions.output)\n              }), {}, {\n                parse: _objectSpread({}, terserOptions.parse),\n                // safari10: terserOptions.safari10,\n                // Ignoring sourceMap from options\n                // eslint-disable-next-line no-undefined\n                sourceMap: undefined // toplevel: terserOptions.toplevel\n\n              });\n            }; // eslint-disable-next-line global-require\n\n\n            _require = require(\"terser\"), minify = _require.minify; // Copy `terser` options\n\n            terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n            if (sourceMap) {\n              // @ts-ignore\n              terserOptions.sourceMap = {\n                asObject: true\n              };\n            }\n            /** @type {ExtractedComments} */\n\n\n            extractedComments = [];\n\n            if (terserOptions.output) {\n              terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n            } else if (terserOptions.format) {\n              terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n            }\n\n            _Object$entries = Object.entries(input), _Object$entries2 = _slicedToArray(_Object$entries, 1), _Object$entries2$ = _slicedToArray(_Object$entries2[0], 2), filename = _Object$entries2$[0], code = _Object$entries2$[1];\n            _context.next = 11;\n            return minify(_defineProperty({}, filename, code), terserOptions);\n\n          case 11:\n            result = _context.sent;\n            return _context.abrupt(\"return\", {\n              code:\n              /** @type {string} **/\n              result.code,\n              // @ts-ignore\n              // eslint-disable-next-line no-undefined\n              map: result.map ?\n              /** @type {RawSourceMap} **/\n              result.map : undefined,\n              extractedComments: extractedComments\n            });\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _terserMinify.apply(this, arguments);\n}\n\nterserMinify.getMinimizerVersion = function () {\n  var packageJson;\n\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nfunction uglifyJsMinify(_x5, _x6, _x7, _x8) {\n  return _uglifyJsMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\n\n\nfunction _uglifyJsMinify() {\n  _uglifyJsMinify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(input, sourceMap, minimizerOptions, extractComments) {\n    var isObject, buildComments, buildUglifyJsOptions, _require2, minify, uglifyJsOptions, extractedComments, _Object$entries3, _Object$entries4, _Object$entries4$, filename, code, result;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            /**\n             * @param {any} value\n             * @returns {boolean}\n             */\n            isObject = function isObject(value) {\n              var type = _typeof(value);\n\n              return value != null && (type === \"object\" || type === \"function\");\n            };\n            /**\n             * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\n             * @param {ExtractedComments} extractedComments\n             * @returns {ExtractCommentsFunction}\n             */\n\n\n            buildComments = function buildComments(uglifyJsOptions, extractedComments) {\n              /** @type {{ [index: string]: ExtractCommentsCondition }} */\n              var condition = {};\n              var comments = uglifyJsOptions.output.comments;\n              condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n              if (typeof extractComments === \"boolean\" && extractComments) {\n                condition.extract = \"some\";\n              } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n                condition.extract = extractComments;\n              } else if (typeof extractComments === \"function\") {\n                condition.extract = extractComments;\n              } else if (extractComments && isObject(extractComments)) {\n                condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n              } else {\n                // No extract\n                // Preserve using \"commentsOpts\" or \"some\"\n                condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n                condition.extract = false;\n              } // Ensure that both conditions are functions\n\n\n              [\"preserve\", \"extract\"].forEach(function (key) {\n                /** @type {undefined | string} */\n                var regexStr;\n                /** @type {undefined | RegExp} */\n\n                var regex;\n\n                switch (_typeof(condition[key])) {\n                  case \"boolean\":\n                    condition[key] = condition[key] ? function () {\n                      return true;\n                    } : function () {\n                      return false;\n                    };\n                    break;\n\n                  case \"function\":\n                    break;\n\n                  case \"string\":\n                    if (condition[key] === \"all\") {\n                      condition[key] = function () {\n                        return true;\n                      };\n\n                      break;\n                    }\n\n                    if (condition[key] === \"some\") {\n                      condition[key] =\n                      /** @type {ExtractCommentsFunction} */\n                      function (astNode, comment) {\n                        return (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n                      };\n\n                      break;\n                    }\n\n                    regexStr =\n                    /** @type {string} */\n                    condition[key];\n\n                    condition[key] =\n                    /** @type {ExtractCommentsFunction} */\n                    function (astNode, comment) {\n                      return new RegExp(\n                      /** @type {string} */\n                      regexStr).test(comment.value);\n                    };\n\n                    break;\n\n                  default:\n                    regex =\n                    /** @type {RegExp} */\n                    condition[key];\n\n                    condition[key] =\n                    /** @type {ExtractCommentsFunction} */\n                    function (astNode, comment) {\n                      return (\n                        /** @type {RegExp} */\n                        regex.test(comment.value)\n                      );\n                    };\n\n                }\n              }); // Redefine the comments function to extract and preserve\n              // comments according to the two conditions\n\n              return function (astNode, comment) {\n                if (\n                /** @type {{ extract: ExtractCommentsFunction }} */\n                condition.extract(astNode, comment)) {\n                  var commentText = comment.type === \"comment2\" ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value); // Don't include duplicate comments\n\n                  if (!extractedComments.includes(commentText)) {\n                    extractedComments.push(commentText);\n                  }\n                }\n\n                return (\n                  /** @type {{ preserve: ExtractCommentsFunction }} */\n                  condition.preserve(astNode, comment)\n                );\n              };\n            };\n            /**\n             * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\n             * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\n             */\n\n\n            buildUglifyJsOptions = function buildUglifyJsOptions() {\n              var uglifyJsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              // eslint-disable-next-line no-param-reassign\n              delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\n\n              delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n              return _objectSpread(_objectSpread({}, uglifyJsOptions), {}, {\n                // warnings: uglifyJsOptions.warnings,\n                parse: _objectSpread({}, uglifyJsOptions.parse),\n                compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : _objectSpread({}, uglifyJsOptions.compress),\n                mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : _objectSpread({}, uglifyJsOptions.mangle),\n                output: _objectSpread({\n                  beautify: false\n                }, uglifyJsOptions.output),\n                // Ignoring sourceMap from options\n                // eslint-disable-next-line no-undefined\n                sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\n                // nameCache: { ...uglifyJsOptions.toplevel },\n                // ie8: uglifyJsOptions.ie8,\n                // keep_fnames: uglifyJsOptions.keep_fnames,\n\n              });\n            }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n\n\n            _require2 = require(\"uglify-js\"), minify = _require2.minify; // Copy `uglify-js` options\n\n            uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\n\n            if (sourceMap) {\n              // @ts-ignore\n              uglifyJsOptions.sourceMap = true;\n            }\n            /** @type {ExtractedComments} */\n\n\n            extractedComments = []; // @ts-ignore\n\n            uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n            _Object$entries3 = Object.entries(input), _Object$entries4 = _slicedToArray(_Object$entries3, 1), _Object$entries4$ = _slicedToArray(_Object$entries4[0], 2), filename = _Object$entries4$[0], code = _Object$entries4$[1];\n            _context2.next = 11;\n            return minify(_defineProperty({}, filename, code), uglifyJsOptions);\n\n          case 11:\n            result = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              code: result.code,\n              // eslint-disable-next-line no-undefined\n              map: result.map ? JSON.parse(result.map) : undefined,\n              errors: result.error ? [result.error] : [],\n              warnings: result.warnings || [],\n              extractedComments: extractedComments\n            });\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _uglifyJsMinify.apply(this, arguments);\n}\n\nuglifyJsMinify.getMinimizerVersion = function () {\n  var packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nfunction swcMinify(_x9, _x10, _x11) {\n  return _swcMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\n\n\nfunction _swcMinify() {\n  _swcMinify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(input, sourceMap, minimizerOptions) {\n    var buildSwcOptions, swc, swcOptions, _Object$entries5, _Object$entries6, _Object$entries6$, filename, code, result, map;\n\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            /**\n             * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\n             * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined }}\n             */\n            buildSwcOptions = function buildSwcOptions() {\n              var swcOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n              return _objectSpread(_objectSpread({}, swcOptions), {}, {\n                compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress : _objectSpread({}, swcOptions.compress),\n                mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : _objectSpread({}, swcOptions.mangle),\n                // ecma: swcOptions.ecma,\n                // keep_classnames: swcOptions.keep_classnames,\n                // keep_fnames: swcOptions.keep_fnames,\n                // module: swcOptions.module,\n                // safari10: swcOptions.safari10,\n                // toplevel: swcOptions.toplevel\n                // eslint-disable-next-line no-undefined\n                sourceMap: undefined\n              });\n            }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n            swc = require(\"@swc/core\"); // Copy `swc` options\n\n            swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\n\n            if (sourceMap) {\n              // @ts-ignore\n              swcOptions.sourceMap = true;\n            }\n\n            _Object$entries5 = Object.entries(input), _Object$entries6 = _slicedToArray(_Object$entries5, 1), _Object$entries6$ = _slicedToArray(_Object$entries6[0], 2), filename = _Object$entries6$[0], code = _Object$entries6$[1];\n            _context3.next = 7;\n            return swc.minify(code, swcOptions);\n\n          case 7:\n            result = _context3.sent;\n\n            if (result.map) {\n              map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n\n              map.sources = [filename];\n              delete map.sourcesContent;\n            }\n\n            return _context3.abrupt(\"return\", {\n              code: result.code,\n              map: map\n            });\n\n          case 10:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _swcMinify.apply(this, arguments);\n}\n\nswcMinify.getMinimizerVersion = function () {\n  var packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nfunction esbuildMinify(_x12, _x13, _x14) {\n  return _esbuildMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\n\n\nfunction _esbuildMinify() {\n  _esbuildMinify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(input, sourceMap, minimizerOptions) {\n    var buildEsbuildOptions, esbuild, esbuildOptions, _Object$entries7, _Object$entries8, _Object$entries8$, filename, code, result;\n\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            /**\n             * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\n             * @returns {import(\"esbuild\").TransformOptions}\n             */\n            buildEsbuildOptions = function buildEsbuildOptions() {\n              var esbuildOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              // eslint-disable-next-line no-param-reassign\n              delete esbuildOptions.ecma;\n\n              if (esbuildOptions.module) {\n                // eslint-disable-next-line no-param-reassign\n                esbuildOptions.format = \"esm\";\n              } // eslint-disable-next-line no-param-reassign\n\n\n              delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n              return _objectSpread(_objectSpread({\n                minify: true,\n                legalComments: \"inline\"\n              }, esbuildOptions), {}, {\n                sourcemap: false\n              });\n            }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n            esbuild = require(\"esbuild\"); // Copy `esbuild` options\n\n            esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\n\n            if (sourceMap) {\n              esbuildOptions.sourcemap = true;\n              esbuildOptions.sourcesContent = false;\n            }\n\n            _Object$entries7 = Object.entries(input), _Object$entries8 = _slicedToArray(_Object$entries7, 1), _Object$entries8$ = _slicedToArray(_Object$entries8[0], 2), filename = _Object$entries8$[0], code = _Object$entries8$[1];\n            esbuildOptions.sourcefile = filename;\n            _context4.next = 8;\n            return esbuild.transform(code, esbuildOptions);\n\n          case 8:\n            result = _context4.sent;\n            return _context4.abrupt(\"return\", {\n              code: result.code,\n              // eslint-disable-next-line no-undefined\n              map: result.map ? JSON.parse(result.map) : undefined,\n              warnings: result.warnings.length > 0 ? result.warnings.map(function (item) {\n                return {\n                  name: \"Warning\",\n                  source: item.location && item.location.file,\n                  line: item.location && item.location.line,\n                  column: item.location && item.location.column,\n                  plugin: item.pluginName,\n                  message: \"\".concat(item.text).concat(item.detail ? \"\\nDetails:\\n\".concat(item.detail) : \"\").concat(item.notes.length > 0 ? \"\\n\\nNotes:\\n\".concat(item.notes.map(function (note) {\n                    return \"\".concat(note.location ? \"[\".concat(note.location.file, \":\").concat(note.location.line, \":\").concat(note.location.column, \"] \") : \"\").concat(note.text).concat(note.location ? \"\\nSuggestion: \".concat(note.location.suggestion) : \"\").concat(note.location ? \"\\nLine text:\\n\".concat(note.location.lineText, \"\\n\") : \"\");\n                  }).join(\"\\n\")) : \"\")\n                };\n              }) : []\n            });\n\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _esbuildMinify.apply(this, arguments);\n}\n\nesbuildMinify.getMinimizerVersion = function () {\n  var packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n\nmodule.exports = {\n  throttleAll: throttleAll,\n  terserMinify: terserMinify,\n  uglifyJsMinify: uglifyJsMinify,\n  swcMinify: swcMinify,\n  esbuildMinify: esbuildMinify\n};","map":{"version":3,"names":["notSettled","Symbol","throttleAll","limit","tasks","Number","isInteger","TypeError","Array","isArray","every","task","Promise","resolve","reject","result","length","fill","entries","next","done","value","isLast","includes","index","onFulfilled","x","then","forEach","terserMinify","input","sourceMap","minimizerOptions","extractComments","isObject","type","buildComments","terserOptions","extractedComments","condition","comments","format","output","preserve","extract","RegExp","key","regexStr","regex","astNode","comment","test","commentText","push","buildTerserOptions","compress","mangle","beautify","parse","undefined","require","minify","asObject","Object","filename","code","map","getMinimizerVersion","packageJson","error","version","uglifyJsMinify","uglifyJsOptions","buildUglifyJsOptions","ecma","module","JSON","errors","warnings","swcMinify","buildSwcOptions","swcOptions","swc","sources","sourcesContent","esbuildMinify","buildEsbuildOptions","esbuildOptions","legalComments","sourcemap","esbuild","sourcefile","transform","item","name","source","location","file","line","column","plugin","pluginName","message","text","detail","notes","note","suggestion","lineText","join","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/terser-webpack-plugin/dist/utils.js"],"sourcesContent":["\"use strict\";\n\n/** @typedef {import(\"source-map\").RawSourceMap} RawSourceMap */\n\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/** @typedef {import(\"./index.js\").Input} Input */\n\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\nconst notSettled = Symbol(`not-settled`);\n/**\n * @template T\n * @typedef {() => Promise<T>} Task\n */\n\n/**\n * Run tasks with limited concurency.\n * @template T\n * @param {number} limit - Limit of tasks that run at once.\n * @param {Task<T>[]} tasks - List of tasks to run.\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\n */\n\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(`Expected \\`limit\\` to be a finite number > 0, got \\`${limit}\\` (${typeof limit})`);\n  }\n\n  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {\n    throw new TypeError(`Expected \\`tasks\\` to be a list of functions returning a promise`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const result = Array(tasks.length).fill(notSettled);\n    const entries = tasks.entries();\n\n    const next = () => {\n      const {\n        done,\n        value\n      } = entries.next();\n\n      if (done) {\n        const isLast = !result.includes(notSettled);\n        if (isLast) resolve(\n        /** @type{T[]} **/\n        result);\n        return;\n      }\n\n      const [index, task] = value;\n      /**\n       * @param {T} x\n       */\n\n      const onFulfilled = x => {\n        result[index] = x;\n        next();\n      };\n\n      task().then(onFulfilled, reject);\n    };\n\n    Array(limit).fill(0).forEach(next);\n  });\n}\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function terserMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\n   * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n\n\n  const buildComments = (terserOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    let comments;\n\n    if (terserOptions.format) {\n      ({\n        comments\n      } = terserOptions.format);\n    } else if (terserOptions.output) {\n      ({\n        comments\n      } = terserOptions.output);\n    }\n\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n\n        case \"function\":\n          break;\n\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n\n            break;\n          }\n\n          if (condition[key] === \"some\") {\n            condition[key] =\n            /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n            break;\n          }\n\n          regexStr =\n          /** @type {string} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp(\n          /** @type {string} */\n          regexStr).test(comment.value);\n\n          break;\n\n        default:\n          regex =\n          /** @type {RegExp} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) =>\n          /** @type {RegExp} */\n          regex.test(comment.value);\n\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if (\n      /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n\n      return (\n        /** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\n   * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\n   * @returns {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\n   */\n\n\n  const buildTerserOptions = (terserOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return { ...terserOptions,\n      compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress : { ...terserOptions.compress\n      },\n      // ecma: terserOptions.ecma,\n      // ie8: terserOptions.ie8,\n      // keep_classnames: terserOptions.keep_classnames,\n      // keep_fnames: terserOptions.keep_fnames,\n      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : { ...terserOptions.mangle\n      },\n      // module: terserOptions.module,\n      // nameCache: { ...terserOptions.toplevel },\n      // the `output` option is deprecated\n      ...(terserOptions.format ? {\n        format: {\n          beautify: false,\n          ...terserOptions.format\n        }\n      } : {\n        output: {\n          beautify: false,\n          ...terserOptions.output\n        }\n      }),\n      parse: { ...terserOptions.parse\n      },\n      // safari10: terserOptions.safari10,\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: terserOptions.toplevel\n\n    };\n  }; // eslint-disable-next-line global-require\n\n\n  const {\n    minify\n  } = require(\"terser\"); // Copy `terser` options\n\n\n  const terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = [];\n\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, terserOptions);\n  return {\n    code:\n    /** @type {string} **/\n    result.code,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    map: result.map ?\n    /** @type {RawSourceMap} **/\n    result.map : undefined,\n    extractedComments\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nterserMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\n   * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n\n\n  const buildComments = (uglifyJsOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    const {\n      comments\n    } = uglifyJsOptions.output;\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n\n        case \"function\":\n          break;\n\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n\n            break;\n          }\n\n          if (condition[key] === \"some\") {\n            condition[key] =\n            /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n            break;\n          }\n\n          regexStr =\n          /** @type {string} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp(\n          /** @type {string} */\n          regexStr).test(comment.value);\n\n          break;\n\n        default:\n          regex =\n          /** @type {RegExp} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) =>\n          /** @type {RegExp} */\n          regex.test(comment.value);\n\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if (\n      /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n\n      return (\n        /** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\n   * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\n   * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\n   */\n\n\n  const buildUglifyJsOptions = (uglifyJsOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\n\n    delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return { ...uglifyJsOptions,\n      // warnings: uglifyJsOptions.warnings,\n      parse: { ...uglifyJsOptions.parse\n      },\n      compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : { ...uglifyJsOptions.compress\n      },\n      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : { ...uglifyJsOptions.mangle\n      },\n      output: {\n        beautify: false,\n        ...uglifyJsOptions.output\n      },\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\n      // nameCache: { ...uglifyJsOptions.toplevel },\n      // ie8: uglifyJsOptions.ie8,\n      // keep_fnames: uglifyJsOptions.keep_fnames,\n\n    };\n  }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n\n\n  const {\n    minify\n  } = require(\"uglify-js\"); // Copy `uglify-js` options\n\n\n  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    uglifyJsOptions.sourceMap = true;\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = []; // @ts-ignore\n\n  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, uglifyJsOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    errors: result.error ? [result.error] : [],\n    warnings: result.warnings || [],\n    extractedComments\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nuglifyJsMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function swcMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\n   * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined }}\n   */\n  const buildSwcOptions = (swcOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return { ...swcOptions,\n      compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress : { ...swcOptions.compress\n      },\n      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : { ...swcOptions.mangle\n      },\n      // ecma: swcOptions.ecma,\n      // keep_classnames: swcOptions.keep_classnames,\n      // keep_fnames: swcOptions.keep_fnames,\n      // module: swcOptions.module,\n      // safari10: swcOptions.safari10,\n      // toplevel: swcOptions.toplevel\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n  const swc = require(\"@swc/core\"); // Copy `swc` options\n\n\n  const swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    swcOptions.sourceMap = true;\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  const result = await swc.minify(code, swcOptions);\n  let map;\n\n  if (result.map) {\n    map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n\n    map.sources = [filename];\n    delete map.sourcesContent;\n  }\n\n  return {\n    code: result.code,\n    map\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nswcMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {RawSourceMap | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function esbuildMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\n   * @returns {import(\"esbuild\").TransformOptions}\n   */\n  const buildEsbuildOptions = (esbuildOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete esbuildOptions.ecma;\n\n    if (esbuildOptions.module) {\n      // eslint-disable-next-line no-param-reassign\n      esbuildOptions.format = \"esm\";\n    } // eslint-disable-next-line no-param-reassign\n\n\n    delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return {\n      minify: true,\n      legalComments: \"inline\",\n      ...esbuildOptions,\n      sourcemap: false\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n  const esbuild = require(\"esbuild\"); // Copy `esbuild` options\n\n\n  const esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\n\n  if (sourceMap) {\n    esbuildOptions.sourcemap = true;\n    esbuildOptions.sourcesContent = false;\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  esbuildOptions.sourcefile = filename;\n  const result = await esbuild.transform(code, esbuildOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    warnings: result.warnings.length > 0 ? result.warnings.map(item => {\n      return {\n        name: \"Warning\",\n        source: item.location && item.location.file,\n        line: item.location && item.location.line,\n        column: item.location && item.location.column,\n        plugin: item.pluginName,\n        message: `${item.text}${item.detail ? `\\nDetails:\\n${item.detail}` : \"\"}${item.notes.length > 0 ? `\\n\\nNotes:\\n${item.notes.map(note => `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : \"\"}${note.text}${note.location ? `\\nSuggestion: ${note.location.suggestion}` : \"\"}${note.location ? `\\nLine text:\\n${note.location.lineText}\\n` : \"\"}`).join(\"\\n\")}` : \"\"}`\n      };\n    }) : []\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nesbuildMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n\nmodule.exports = {\n  throttleAll,\n  terserMinify,\n  uglifyJsMinify,\n  swcMinify,\n  esbuildMinify\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}