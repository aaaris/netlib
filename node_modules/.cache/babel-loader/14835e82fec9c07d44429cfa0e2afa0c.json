{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.array.sort.js\");\n\nrequire(\"core-js/modules/es.array.for-each.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n    getMap = _require.getMap,\n    getSourceAndMap = _require.getSourceAndMap;\n\nvar _streamChunks = require(\"./helpers/streamChunks\");\n\nvar Source = require(\"./Source\");\n\nvar splitIntoLines = require(\"./helpers/splitIntoLines\"); // since v8 7.0, Array.prototype.sort is stable\n\n\nvar hasStableSort = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === \"object\" && process.versions && typeof process.versions.v8 === \"string\" && !/^[0-6]\\./.test(process.versions.v8); // This is larger than max string length\n\nvar MAX_SOURCE_POSITION = 0x20000000;\n\nvar Replacement = /*#__PURE__*/_createClass(function Replacement(start, end, content, name) {\n  _classCallCheck(this, Replacement);\n\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.name = name;\n\n  if (!hasStableSort) {\n    this.index = -1;\n  }\n});\n\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n\n  var _super = _createSuper(ReplaceSource);\n\n  function ReplaceSource(source, name) {\n    var _this;\n\n    _classCallCheck(this, ReplaceSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n\n    _this._replacements = [];\n    _this._isSorted = true;\n    return _this;\n  }\n\n  _createClass(ReplaceSource, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"getReplacements\",\n    value: function getReplacements() {\n      this._sortReplacements();\n\n      return this._replacements;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + _typeof(newValue));\n\n      this._replacements.push(new Replacement(start, end, newValue, name));\n\n      this._isSorted = false;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + _typeof(newValue) + \": \" + newValue);\n\n      this._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\n      this._isSorted = false;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (this._replacements.length === 0) {\n        return this._source.source();\n      }\n\n      var current = this._source.source();\n\n      var pos = 0;\n      var result = [];\n\n      this._sortReplacements();\n\n      var _iterator = _createForOfIteratorHelper(this._replacements),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var replacement = _step.value;\n          var start = Math.floor(replacement.start);\n          var end = Math.floor(replacement.end + 1);\n\n          if (pos < start) {\n            var offset = start - pos;\n            result.push(current.slice(0, offset));\n            current = current.slice(offset);\n            pos = start;\n          }\n\n          result.push(replacement.content);\n\n          if (pos < end) {\n            var _offset = end - pos;\n\n            current = current.slice(_offset);\n            pos = end;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      result.push(current);\n      return result.join(\"\");\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      if (this._replacements.length === 0) {\n        return this._source.map(options);\n      }\n\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      if (this._replacements.length === 0) {\n        return this._source.sourceAndMap(options);\n      }\n\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      if (this._isSorted) return;\n\n      if (hasStableSort) {\n        this._replacements.sort(function (a, b) {\n          var diff1 = a.start - b.start;\n          if (diff1 !== 0) return diff1;\n          var diff2 = a.end - b.end;\n          if (diff2 !== 0) return diff2;\n          return 0;\n        });\n      } else {\n        this._replacements.forEach(function (repl, i) {\n          return repl.index = i;\n        });\n\n        this._replacements.sort(function (a, b) {\n          var diff1 = a.start - b.start;\n          if (diff1 !== 0) return diff1;\n          var diff2 = a.end - b.end;\n          if (diff2 !== 0) return diff2;\n          return a.index - b.index;\n        });\n      }\n\n      this._isSorted = true;\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      this._sortReplacements();\n\n      var repls = this._replacements;\n      var pos = 0;\n      var i = 0;\n      var replacmentEnd = -1;\n      var nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n      var generatedLineOffset = 0;\n      var generatedColumnOffset = 0;\n      var generatedColumnOffsetLine = 0;\n      var sourceContents = [];\n      var nameMapping = new Map();\n      var nameIndexMapping = [];\n\n      var checkOriginalContent = function checkOriginalContent(sourceIndex, line, column, expectedChunk) {\n        var content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : undefined;\n        if (content === undefined) return false;\n\n        if (typeof content === \"string\") {\n          content = splitIntoLines(content);\n          sourceContents[sourceIndex] = content;\n        }\n\n        var contentLine = line <= content.length ? content[line - 1] : null;\n        if (contentLine === null) return false;\n        return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;\n      };\n\n      var _streamChunks2 = _streamChunks(this._source, Object.assign({}, options, {\n        finalSource: false\n      }), function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n        var chunkPos = 0;\n        var endPos = pos + chunk.length; // Skip over when it has been replaced\n\n        // Skip over when it has been replaced\n        if (replacmentEnd > pos) {\n          // Skip over the whole chunk\n          if (replacmentEnd >= endPos) {\n            var _line2 = generatedLine + generatedLineOffset;\n\n            if (chunk.endsWith(\"\\n\")) {\n              generatedLineOffset--;\n\n              if (generatedColumnOffsetLine === _line2) {\n                // undo exiting corrections form the current line\n                generatedColumnOffset += generatedColumn;\n              }\n            } else if (generatedColumnOffsetLine === _line2) {\n              generatedColumnOffset -= chunk.length;\n            } else {\n              generatedColumnOffset = -chunk.length;\n              generatedColumnOffsetLine = _line2;\n            }\n\n            pos = endPos;\n            return;\n          } // Partially skip over chunk\n\n\n          // Partially skip over chunk\n          chunkPos = replacmentEnd - pos;\n\n          if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos))) {\n            originalColumn += chunkPos;\n          }\n\n          pos += chunkPos;\n\n          var _line = generatedLine + generatedLineOffset;\n\n          if (generatedColumnOffsetLine === _line) {\n            generatedColumnOffset -= chunkPos;\n          } else {\n            generatedColumnOffset = -chunkPos;\n            generatedColumnOffsetLine = _line;\n          }\n\n          generatedColumn += chunkPos;\n        } // Is a replacement in the chunk?\n\n\n        // Is a replacement in the chunk?\n        if (nextReplacement < endPos) {\n          do {\n            var _line3 = generatedLine + generatedLineOffset;\n\n            if (nextReplacement > pos) {\n              // Emit chunk until replacement\n              var _offset2 = nextReplacement - pos;\n\n              var chunkSlice = chunk.slice(chunkPos, chunkPos + _offset2);\n              onChunk(chunkSlice, _line3, generatedColumn + (_line3 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]);\n              generatedColumn += _offset2;\n              chunkPos += _offset2;\n              pos = nextReplacement;\n\n              if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice)) {\n                originalColumn += chunkSlice.length;\n              }\n            } // Insert replacement content splitted into chunks by lines\n\n\n            // Insert replacement content splitted into chunks by lines\n            var _repls$i = repls[i],\n                content = _repls$i.content,\n                name = _repls$i.name;\n\n            var _matches = splitIntoLines(content);\n\n            var replacementNameIndex = nameIndex;\n\n            if (sourceIndex >= 0 && name) {\n              var globalIndex = nameMapping.get(name);\n\n              if (globalIndex === undefined) {\n                globalIndex = nameMapping.size;\n                nameMapping.set(name, globalIndex);\n                onName(globalIndex, name);\n              }\n\n              replacementNameIndex = globalIndex;\n            }\n\n            for (var m = 0; m < _matches.length; m++) {\n              var contentLine = _matches[m];\n              onChunk(contentLine, _line3, generatedColumn + (_line3 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex); // Only the first chunk has name assigned\n\n              // Only the first chunk has name assigned\n              replacementNameIndex = -1;\n\n              if (m === _matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n                if (generatedColumnOffsetLine === _line3) {\n                  generatedColumnOffset += contentLine.length;\n                } else {\n                  generatedColumnOffset = contentLine.length;\n                  generatedColumnOffsetLine = _line3;\n                }\n              } else {\n                generatedLineOffset++;\n                _line3++;\n                generatedColumnOffset = -generatedColumn;\n                generatedColumnOffsetLine = _line3;\n              }\n            } // Remove replaced content by settings this variable\n\n\n            // Remove replaced content by settings this variable\n            replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1)); // Move to next replacment\n\n            // Move to next replacment\n            i++;\n            nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION; // Skip over when it has been replaced\n\n            // Skip over when it has been replaced\n            var offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\n            if (offset > 0) {\n              // Skip over whole chunk\n              if (replacmentEnd >= endPos) {\n                var _line5 = generatedLine + generatedLineOffset;\n\n                if (chunk.endsWith(\"\\n\")) {\n                  generatedLineOffset--;\n\n                  if (generatedColumnOffsetLine === _line5) {\n                    // undo exiting corrections form the current line\n                    generatedColumnOffset += generatedColumn;\n                  }\n                } else if (generatedColumnOffsetLine === _line5) {\n                  generatedColumnOffset -= chunk.length - chunkPos;\n                } else {\n                  generatedColumnOffset = chunkPos - chunk.length;\n                  generatedColumnOffsetLine = _line5;\n                }\n\n                pos = endPos;\n                return;\n              } // Partially skip over chunk\n\n\n              // Partially skip over chunk\n              var _line4 = generatedLine + generatedLineOffset;\n\n              if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset))) {\n                originalColumn += offset;\n              }\n\n              chunkPos += offset;\n              pos += offset;\n\n              if (generatedColumnOffsetLine === _line4) {\n                generatedColumnOffset -= offset;\n              } else {\n                generatedColumnOffset = -offset;\n                generatedColumnOffsetLine = _line4;\n              }\n\n              generatedColumn += offset;\n            }\n          } while (nextReplacement < endPos);\n        } // Emit remaining chunk\n\n\n        // Emit remaining chunk\n        if (chunkPos < chunk.length) {\n          var _chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\n          var _line6 = generatedLine + generatedLineOffset;\n\n          onChunk(_chunkSlice, _line6, generatedColumn + (_line6 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);\n        }\n\n        pos = endPos;\n      }, function (sourceIndex, source, sourceContent) {\n        while (sourceContents.length < sourceIndex) {\n          sourceContents.push(undefined);\n        }\n\n        sourceContents[sourceIndex] = sourceContent;\n        onSource(sourceIndex, source, sourceContent);\n      }, function (nameIndex, name) {\n        var globalIndex = nameMapping.get(name);\n\n        if (globalIndex === undefined) {\n          globalIndex = nameMapping.size;\n          nameMapping.set(name, globalIndex);\n          onName(globalIndex, name);\n        }\n\n        nameIndexMapping[nameIndex] = globalIndex;\n      }),\n          generatedLine = _streamChunks2.generatedLine,\n          generatedColumn = _streamChunks2.generatedColumn; // Handle remaining replacements\n\n\n      var remainer = \"\";\n\n      for (; i < repls.length; i++) {\n        remainer += repls[i].content;\n      } // Insert remaining replacements content splitted into chunks by lines\n\n\n      var line = generatedLine + generatedLineOffset;\n      var matches = splitIntoLines(remainer);\n\n      for (var m = 0; m < matches.length; m++) {\n        var contentLine = matches[m];\n        onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1);\n\n        if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n          if (generatedColumnOffsetLine === line) {\n            generatedColumnOffset += contentLine.length;\n          } else {\n            generatedColumnOffset = contentLine.length;\n            generatedColumnOffsetLine = line;\n          }\n        } else {\n          generatedLineOffset++;\n          line++;\n          generatedColumnOffset = -generatedColumn;\n          generatedColumnOffsetLine = line;\n        }\n      }\n\n      return {\n        generatedLine: line,\n        generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      this._sortReplacements();\n\n      hash.update(\"ReplaceSource\");\n\n      this._source.updateHash(hash);\n\n      hash.update(this._name || \"\");\n\n      var _iterator2 = _createForOfIteratorHelper(this._replacements),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var repl = _step2.value;\n          hash.update(\"\".concat(repl.start).concat(repl.end).concat(repl.content).concat(repl.name));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return ReplaceSource;\n}(Source);\n\nmodule.exports = ReplaceSource;","map":{"version":3,"names":["require","getMap","getSourceAndMap","streamChunks","Source","splitIntoLines","hasStableSort","process","versions","v8","test","MAX_SOURCE_POSITION","Replacement","start","end","content","name","index","ReplaceSource","source","_source","_name","_replacements","_isSorted","_sortReplacements","newValue","Error","push","pos","length","current","result","replacement","Math","floor","offset","slice","join","options","map","sourceAndMap","sort","a","b","diff1","diff2","forEach","repl","i","onChunk","onSource","onName","repls","replacmentEnd","nextReplacement","generatedLineOffset","generatedColumnOffset","generatedColumnOffsetLine","sourceContents","nameMapping","Map","nameIndexMapping","checkOriginalContent","sourceIndex","line","column","expectedChunk","undefined","contentLine","Object","assign","finalSource","chunk","generatedLine","generatedColumn","originalLine","originalColumn","nameIndex","chunkPos","endPos","endsWith","chunkSlice","matches","replacementNameIndex","globalIndex","get","size","set","m","max","sourceContent","remainer","hash","update","updateHash","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/webpack-sources/lib/ReplaceSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst Source = require(\"./Source\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort =\n\ttypeof process === \"object\" &&\n\tprocess.versions &&\n\ttypeof process.versions.v8 === \"string\" &&\n\t!/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n\tconstructor(start, end, content, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.name = name;\n\t\tif (!hasStableSort) {\n\t\t\tthis.index = -1;\n\t\t}\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tthis._sortReplacements();\n\t\treturn this._replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.source();\n\t\t}\n\t\tlet current = this._source.source();\n\t\tlet pos = 0;\n\t\tconst result = [];\n\n\t\tthis._sortReplacements();\n\t\tfor (const replacement of this._replacements) {\n\t\t\tconst start = Math.floor(replacement.start);\n\t\t\tconst end = Math.floor(replacement.end + 1);\n\t\t\tif (pos < start) {\n\t\t\t\tconst offset = start - pos;\n\t\t\t\tresult.push(current.slice(0, offset));\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = start;\n\t\t\t}\n\t\t\tresult.push(replacement.content);\n\t\t\tif (pos < end) {\n\t\t\t\tconst offset = end - pos;\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = end;\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result.join(\"\");\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tif (hasStableSort) {\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn a.index - b.index;\n\t\t\t});\n\t\t}\n\t\tthis._isSorted = true;\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._sortReplacements();\n\t\tconst repls = this._replacements;\n\t\tlet pos = 0;\n\t\tlet i = 0;\n\t\tlet replacmentEnd = -1;\n\t\tlet nextReplacement =\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\t\tlet generatedLineOffset = 0;\n\t\tlet generatedColumnOffset = 0;\n\t\tlet generatedColumnOffsetLine = 0;\n\t\tconst sourceContents = [];\n\t\tconst nameMapping = new Map();\n\t\tconst nameIndexMapping = [];\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n\t\t\tlet content =\n\t\t\t\tsourceIndex < sourceContents.length\n\t\t\t\t\t? sourceContents[sourceIndex]\n\t\t\t\t\t: undefined;\n\t\t\tif (content === undefined) return false;\n\t\t\tif (typeof content === \"string\") {\n\t\t\t\tcontent = splitIntoLines(content);\n\t\t\t\tsourceContents[sourceIndex] = content;\n\t\t\t}\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\n\t\t\tif (contentLine === null) return false;\n\t\t\treturn (\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\n\t\t\t\texpectedChunk\n\t\t\t);\n\t\t};\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\n\t\t\tthis._source,\n\t\t\tObject.assign({}, options, { finalSource: false }),\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tlet chunkPos = 0;\n\t\t\t\tlet endPos = pos + chunk.length;\n\n\t\t\t\t// Skip over when it has been replaced\n\t\t\t\tif (replacmentEnd > pos) {\n\t\t\t\t\t// Skip over the whole chunk\n\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\toriginalColumn += chunkPos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += chunkPos;\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t}\n\t\t\t\t\tgeneratedColumn += chunkPos;\n\t\t\t\t}\n\n\t\t\t\t// Is a replacement in the chunk?\n\t\t\t\tif (nextReplacement < endPos) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (nextReplacement > pos) {\n\t\t\t\t\t\t\t// Emit chunk until replacement\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos = nextReplacement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunkSlice\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\n\t\t\t\t\t\tconst { content, name } = repls[i];\n\t\t\t\t\t\tlet matches = splitIntoLines(content);\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\t\t\t\t\tconst contentLine = matches[m];\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tcontentLine,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\treplacementNameIndex\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\n\t\t\t\t\t\t\treplacementNameIndex = -1;\n\n\t\t\t\t\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove replaced content by settings this variable\n\t\t\t\t\t\treplacmentEnd = Math.max(\n\t\t\t\t\t\t\treplacmentEnd,\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Move to next replacment\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnextReplacement =\n\t\t\t\t\t\t\ti < repls.length\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\n\n\t\t\t\t\t\t// Skip over when it has been replaced\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\t// Skip over whole chunk\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos += offset;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (nextReplacement < endPos);\n\t\t\t\t}\n\n\t\t\t\t// Emit remaining chunk\n\t\t\t\tif (chunkPos < chunk.length) {\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpos = endPos;\n\t\t\t},\n\t\t\t(sourceIndex, source, sourceContent) => {\n\t\t\t\twhile (sourceContents.length < sourceIndex)\n\t\t\t\t\tsourceContents.push(undefined);\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\n\t\t\t},\n\t\t\t(nameIndex, name) => {\n\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t}\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\n\t\t\t}\n\t\t);\n\n\t\t// Handle remaining replacements\n\t\tlet remainer = \"\";\n\t\tfor (; i < repls.length; i++) {\n\t\t\tremainer += repls[i].content;\n\t\t}\n\n\t\t// Insert remaining replacements content splitted into chunks by lines\n\t\tlet line = generatedLine + generatedLineOffset;\n\t\tlet matches = splitIntoLines(remainer);\n\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\tconst contentLine = matches[m];\n\t\t\tonChunk(\n\t\t\t\tcontentLine,\n\t\t\t\tline,\n\t\t\t\tgeneratedColumn +\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t);\n\n\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t} else {\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgeneratedLineOffset++;\n\t\t\t\tline++;\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgeneratedLine: line,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn +\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,eAAoCA,OAAO,CAAC,+BAAD,CAA3C;AAAA,IAAQC,MAAR,YAAQA,MAAR;AAAA,IAAgBC,eAAhB,YAAgBA,eAAhB;;AACA,IAAMC,aAAY,GAAGH,OAAO,CAAC,wBAAD,CAA5B;;AACA,IAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMK,cAAc,GAAGL,OAAO,CAAC,0BAAD,CAA9B,C,CAEA;;;AACA,IAAMM,aAAa,GAClB,QAAOC,OAAP,yCAAOA,OAAP,OAAmB,QAAnB,IACAA,OAAO,CAACC,QADR,IAEA,OAAOD,OAAO,CAACC,QAAR,CAAiBC,EAAxB,KAA+B,QAF/B,IAGA,CAAC,WAAWC,IAAX,CAAgBH,OAAO,CAACC,QAAR,CAAiBC,EAAjC,CAJF,C,CAMA;;AACA,IAAME,mBAAmB,GAAG,UAA5B;;IAEMC,W,6BACL,qBAAYC,KAAZ,EAAmBC,GAAnB,EAAwBC,OAAxB,EAAiCC,IAAjC,EAAuC;EAAA;;EACtC,KAAKH,KAAL,GAAaA,KAAb;EACA,KAAKC,GAAL,GAAWA,GAAX;EACA,KAAKC,OAAL,GAAeA,OAAf;EACA,KAAKC,IAAL,GAAYA,IAAZ;;EACA,IAAI,CAACV,aAAL,EAAoB;IACnB,KAAKW,KAAL,GAAa,CAAC,CAAd;EACA;AACD,C;;IAGIC,a;;;;;EACL,uBAAYC,MAAZ,EAAoBH,IAApB,EAA0B;IAAA;;IAAA;;IACzB;IACA,MAAKI,OAAL,GAAeD,MAAf;IACA,MAAKE,KAAL,GAAaL,IAAb;IACA;;IACA,MAAKM,aAAL,GAAqB,EAArB;IACA,MAAKC,SAAL,GAAiB,IAAjB;IANyB;EAOzB;;;;WAED,mBAAU;MACT,OAAO,KAAKF,KAAZ;IACA;;;WAED,2BAAkB;MACjB,KAAKG,iBAAL;;MACA,OAAO,KAAKF,aAAZ;IACA;;;WAED,iBAAQT,KAAR,EAAeC,GAAf,EAAoBW,QAApB,EAA8BT,IAA9B,EAAoC;MACnC,IAAI,OAAOS,QAAP,KAAoB,QAAxB,EACC,MAAM,IAAIC,KAAJ,CACL,kDAAiDD,QAAjD,CADK,CAAN;;MAGD,KAAKH,aAAL,CAAmBK,IAAnB,CAAwB,IAAIf,WAAJ,CAAgBC,KAAhB,EAAuBC,GAAvB,EAA4BW,QAA5B,EAAsCT,IAAtC,CAAxB;;MACA,KAAKO,SAAL,GAAiB,KAAjB;IACA;;;WAED,gBAAOK,GAAP,EAAYH,QAAZ,EAAsBT,IAAtB,EAA4B;MAC3B,IAAI,OAAOS,QAAP,KAAoB,QAAxB,EACC,MAAM,IAAIC,KAAJ,CACL,kDACQD,QADR,IAEC,IAFD,GAGCA,QAJI,CAAN;;MAMD,KAAKH,aAAL,CAAmBK,IAAnB,CAAwB,IAAIf,WAAJ,CAAgBgB,GAAhB,EAAqBA,GAAG,GAAG,CAA3B,EAA8BH,QAA9B,EAAwCT,IAAxC,CAAxB;;MACA,KAAKO,SAAL,GAAiB,KAAjB;IACA;;;WAED,kBAAS;MACR,IAAI,KAAKD,aAAL,CAAmBO,MAAnB,KAA8B,CAAlC,EAAqC;QACpC,OAAO,KAAKT,OAAL,CAAaD,MAAb,EAAP;MACA;;MACD,IAAIW,OAAO,GAAG,KAAKV,OAAL,CAAaD,MAAb,EAAd;;MACA,IAAIS,GAAG,GAAG,CAAV;MACA,IAAMG,MAAM,GAAG,EAAf;;MAEA,KAAKP,iBAAL;;MARQ,2CASkB,KAAKF,aATvB;MAAA;;MAAA;QASR,oDAA8C;UAAA,IAAnCU,WAAmC;UAC7C,IAAMnB,KAAK,GAAGoB,IAAI,CAACC,KAAL,CAAWF,WAAW,CAACnB,KAAvB,CAAd;UACA,IAAMC,GAAG,GAAGmB,IAAI,CAACC,KAAL,CAAWF,WAAW,CAAClB,GAAZ,GAAkB,CAA7B,CAAZ;;UACA,IAAIc,GAAG,GAAGf,KAAV,EAAiB;YAChB,IAAMsB,MAAM,GAAGtB,KAAK,GAAGe,GAAvB;YACAG,MAAM,CAACJ,IAAP,CAAYG,OAAO,CAACM,KAAR,CAAc,CAAd,EAAiBD,MAAjB,CAAZ;YACAL,OAAO,GAAGA,OAAO,CAACM,KAAR,CAAcD,MAAd,CAAV;YACAP,GAAG,GAAGf,KAAN;UACA;;UACDkB,MAAM,CAACJ,IAAP,CAAYK,WAAW,CAACjB,OAAxB;;UACA,IAAIa,GAAG,GAAGd,GAAV,EAAe;YACd,IAAMqB,OAAM,GAAGrB,GAAG,GAAGc,GAArB;;YACAE,OAAO,GAAGA,OAAO,CAACM,KAAR,CAAcD,OAAd,CAAV;YACAP,GAAG,GAAGd,GAAN;UACA;QACD;MAxBO;QAAA;MAAA;QAAA;MAAA;;MAyBRiB,MAAM,CAACJ,IAAP,CAAYG,OAAZ;MACA,OAAOC,MAAM,CAACM,IAAP,CAAY,EAAZ,CAAP;IACA;;;WAED,aAAIC,OAAJ,EAAa;MACZ,IAAI,KAAKhB,aAAL,CAAmBO,MAAnB,KAA8B,CAAlC,EAAqC;QACpC,OAAO,KAAKT,OAAL,CAAamB,GAAb,CAAiBD,OAAjB,CAAP;MACA;;MACD,OAAOrC,MAAM,CAAC,IAAD,EAAOqC,OAAP,CAAb;IACA;;;WAED,sBAAaA,OAAb,EAAsB;MACrB,IAAI,KAAKhB,aAAL,CAAmBO,MAAnB,KAA8B,CAAlC,EAAqC;QACpC,OAAO,KAAKT,OAAL,CAAaoB,YAAb,CAA0BF,OAA1B,CAAP;MACA;;MACD,OAAOpC,eAAe,CAAC,IAAD,EAAOoC,OAAP,CAAtB;IACA;;;WAED,oBAAW;MACV,OAAO,KAAKlB,OAAZ;IACA;;;WAED,6BAAoB;MACnB,IAAI,KAAKG,SAAT,EAAoB;;MACpB,IAAIjB,aAAJ,EAAmB;QAClB,KAAKgB,aAAL,CAAmBmB,IAAnB,CAAwB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UACvC,IAAMC,KAAK,GAAGF,CAAC,CAAC7B,KAAF,GAAU8B,CAAC,CAAC9B,KAA1B;UACA,IAAI+B,KAAK,KAAK,CAAd,EAAiB,OAAOA,KAAP;UACjB,IAAMC,KAAK,GAAGH,CAAC,CAAC5B,GAAF,GAAQ6B,CAAC,CAAC7B,GAAxB;UACA,IAAI+B,KAAK,KAAK,CAAd,EAAiB,OAAOA,KAAP;UACjB,OAAO,CAAP;QACA,CAND;MAOA,CARD,MAQO;QACN,KAAKvB,aAAL,CAAmBwB,OAAnB,CAA2B,UAACC,IAAD,EAAOC,CAAP;UAAA,OAAcD,IAAI,CAAC9B,KAAL,GAAa+B,CAA3B;QAAA,CAA3B;;QACA,KAAK1B,aAAL,CAAmBmB,IAAnB,CAAwB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UACvC,IAAMC,KAAK,GAAGF,CAAC,CAAC7B,KAAF,GAAU8B,CAAC,CAAC9B,KAA1B;UACA,IAAI+B,KAAK,KAAK,CAAd,EAAiB,OAAOA,KAAP;UACjB,IAAMC,KAAK,GAAGH,CAAC,CAAC5B,GAAF,GAAQ6B,CAAC,CAAC7B,GAAxB;UACA,IAAI+B,KAAK,KAAK,CAAd,EAAiB,OAAOA,KAAP;UACjB,OAAOH,CAAC,CAACzB,KAAF,GAAU0B,CAAC,CAAC1B,KAAnB;QACA,CAND;MAOA;;MACD,KAAKM,SAAL,GAAiB,IAAjB;IACA;;;WAED,sBAAae,OAAb,EAAsBW,OAAtB,EAA+BC,QAA/B,EAAyCC,MAAzC,EAAiD;MAChD,KAAK3B,iBAAL;;MACA,IAAM4B,KAAK,GAAG,KAAK9B,aAAnB;MACA,IAAIM,GAAG,GAAG,CAAV;MACA,IAAIoB,CAAC,GAAG,CAAR;MACA,IAAIK,aAAa,GAAG,CAAC,CAArB;MACA,IAAIC,eAAe,GAClBN,CAAC,GAAGI,KAAK,CAACvB,MAAV,GAAmBI,IAAI,CAACC,KAAL,CAAWkB,KAAK,CAACJ,CAAD,CAAL,CAASnC,KAApB,CAAnB,GAAgDF,mBADjD;MAEA,IAAI4C,mBAAmB,GAAG,CAA1B;MACA,IAAIC,qBAAqB,GAAG,CAA5B;MACA,IAAIC,yBAAyB,GAAG,CAAhC;MACA,IAAMC,cAAc,GAAG,EAAvB;MACA,IAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;MACA,IAAMC,gBAAgB,GAAG,EAAzB;;MACA,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,WAAD,EAAcC,IAAd,EAAoBC,MAApB,EAA4BC,aAA5B,EAA8C;QAC1E,IAAInD,OAAO,GACVgD,WAAW,GAAGL,cAAc,CAAC7B,MAA7B,GACG6B,cAAc,CAACK,WAAD,CADjB,GAEGI,SAHJ;QAIA,IAAIpD,OAAO,KAAKoD,SAAhB,EAA2B,OAAO,KAAP;;QAC3B,IAAI,OAAOpD,OAAP,KAAmB,QAAvB,EAAiC;UAChCA,OAAO,GAAGV,cAAc,CAACU,OAAD,CAAxB;UACA2C,cAAc,CAACK,WAAD,CAAd,GAA8BhD,OAA9B;QACA;;QACD,IAAMqD,WAAW,GAAGJ,IAAI,IAAIjD,OAAO,CAACc,MAAhB,GAAyBd,OAAO,CAACiD,IAAI,GAAG,CAAR,CAAhC,GAA6C,IAAjE;QACA,IAAII,WAAW,KAAK,IAApB,EAA0B,OAAO,KAAP;QAC1B,OACCA,WAAW,CAAChC,KAAZ,CAAkB6B,MAAlB,EAA0BA,MAAM,GAAGC,aAAa,CAACrC,MAAjD,MACAqC,aAFD;MAIA,CAhBD;;MAiBA,qBAAyC/D,aAAY,CACpD,KAAKiB,OAD+C,EAEpDiD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBhC,OAAlB,EAA2B;QAAEiC,WAAW,EAAE;MAAf,CAA3B,CAFoD,EAGpD,UACCC,KADD,EAECC,aAFD,EAGCC,eAHD,EAICX,WAJD,EAKCY,YALD,EAMCC,cAND,EAOCC,SAPD,EAQK;QACJ,IAAIC,QAAQ,GAAG,CAAf;QACA,IAAIC,MAAM,GAAGnD,GAAG,GAAG4C,KAAK,CAAC3C,MAAzB,CAFI,CAIJ;;QAAA;QACA,IAAIwB,aAAa,GAAGzB,GAApB,EAAyB;UACxB;UACA,IAAIyB,aAAa,IAAI0B,MAArB,EAA6B;YAC5B,IAAMf,MAAI,GAAGS,aAAa,GAAGlB,mBAA7B;;YACA,IAAIiB,KAAK,CAACQ,QAAN,CAAe,IAAf,CAAJ,EAA0B;cACzBzB,mBAAmB;;cACnB,IAAIE,yBAAyB,KAAKO,MAAlC,EAAwC;gBACvC;gBACAR,qBAAqB,IAAIkB,eAAzB;cACA;YACD,CAND,MAMO,IAAIjB,yBAAyB,KAAKO,MAAlC,EAAwC;cAC9CR,qBAAqB,IAAIgB,KAAK,CAAC3C,MAA/B;YACA,CAFM,MAEA;cACN2B,qBAAqB,GAAG,CAACgB,KAAK,CAAC3C,MAA/B;cACA4B,yBAAyB,GAAGO,MAA5B;YACA;;YACDpC,GAAG,GAAGmD,MAAN;YACA;UACA,CAlBuB,CAoBxB;;;UAAA;UACAD,QAAQ,GAAGzB,aAAa,GAAGzB,GAA3B;;UACA,IACCkC,oBAAoB,CACnBC,WADmB,EAEnBY,YAFmB,EAGnBC,cAHmB,EAInBJ,KAAK,CAACpC,KAAN,CAAY,CAAZ,EAAe0C,QAAf,CAJmB,CADrB,EAOE;YACDF,cAAc,IAAIE,QAAlB;UACA;;UACDlD,GAAG,IAAIkD,QAAP;;UACA,IAAMd,KAAI,GAAGS,aAAa,GAAGlB,mBAA7B;;UACA,IAAIE,yBAAyB,KAAKO,KAAlC,EAAwC;YACvCR,qBAAqB,IAAIsB,QAAzB;UACA,CAFD,MAEO;YACNtB,qBAAqB,GAAG,CAACsB,QAAzB;YACArB,yBAAyB,GAAGO,KAA5B;UACA;;UACDU,eAAe,IAAII,QAAnB;QACA,CA9CG,CAgDJ;;;QAAA;QACA,IAAIxB,eAAe,GAAGyB,MAAtB,EAA8B;UAC7B,GAAG;YACF,IAAIf,MAAI,GAAGS,aAAa,GAAGlB,mBAA3B;;YACA,IAAID,eAAe,GAAG1B,GAAtB,EAA2B;cAC1B;cACA,IAAMO,QAAM,GAAGmB,eAAe,GAAG1B,GAAjC;;cACA,IAAMqD,UAAU,GAAGT,KAAK,CAACpC,KAAN,CAAY0C,QAAZ,EAAsBA,QAAQ,GAAG3C,QAAjC,CAAnB;cACAc,OAAO,CACNgC,UADM,EAENjB,MAFM,EAGNU,eAAe,IACbV,MAAI,KAAKP,yBAAT,GACED,qBADF,GAEE,CAHW,CAHT,EAONO,WAPM,EAQNY,YARM,EASNC,cATM,EAUNC,SAAS,GAAG,CAAZ,IAAiBA,SAAS,IAAIhB,gBAAgB,CAAChC,MAA/C,GACG,CAAC,CADJ,GAEGgC,gBAAgB,CAACgB,SAAD,CAZb,CAAP;cAcAH,eAAe,IAAIvC,QAAnB;cACA2C,QAAQ,IAAI3C,QAAZ;cACAP,GAAG,GAAG0B,eAAN;;cACA,IACCQ,oBAAoB,CACnBC,WADmB,EAEnBY,YAFmB,EAGnBC,cAHmB,EAInBK,UAJmB,CADrB,EAOE;gBACDL,cAAc,IAAIK,UAAU,CAACpD,MAA7B;cACA;YACD,CAjCC,CAmCF;;;YAAA;YACA,eAA0BuB,KAAK,CAACJ,CAAD,CAA/B;YAAA,IAAQjC,OAAR,YAAQA,OAAR;YAAA,IAAiBC,IAAjB,YAAiBA,IAAjB;;YACA,IAAIkE,QAAO,GAAG7E,cAAc,CAACU,OAAD,CAA5B;;YACA,IAAIoE,oBAAoB,GAAGN,SAA3B;;YACA,IAAId,WAAW,IAAI,CAAf,IAAoB/C,IAAxB,EAA8B;cAC7B,IAAIoE,WAAW,GAAGzB,WAAW,CAAC0B,GAAZ,CAAgBrE,IAAhB,CAAlB;;cACA,IAAIoE,WAAW,KAAKjB,SAApB,EAA+B;gBAC9BiB,WAAW,GAAGzB,WAAW,CAAC2B,IAA1B;gBACA3B,WAAW,CAAC4B,GAAZ,CAAgBvE,IAAhB,EAAsBoE,WAAtB;gBACAjC,MAAM,CAACiC,WAAD,EAAcpE,IAAd,CAAN;cACA;;cACDmE,oBAAoB,GAAGC,WAAvB;YACA;;YACD,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAAO,CAACrD,MAA5B,EAAoC2D,CAAC,EAArC,EAAyC;cACxC,IAAMpB,WAAW,GAAGc,QAAO,CAACM,CAAD,CAA3B;cACAvC,OAAO,CACNmB,WADM,EAENJ,MAFM,EAGNU,eAAe,IACbV,MAAI,KAAKP,yBAAT,GACED,qBADF,GAEE,CAHW,CAHT,EAONO,WAPM,EAQNY,YARM,EASNC,cATM,EAUNO,oBAVM,CAAP,CAFwC,CAexC;;cAAA;cACAA,oBAAoB,GAAG,CAAC,CAAxB;;cAEA,IAAIK,CAAC,KAAKN,QAAO,CAACrD,MAAR,GAAiB,CAAvB,IAA4B,CAACuC,WAAW,CAACY,QAAZ,CAAqB,IAArB,CAAjC,EAA6D;gBAC5D,IAAIvB,yBAAyB,KAAKO,MAAlC,EAAwC;kBACvCR,qBAAqB,IAAIY,WAAW,CAACvC,MAArC;gBACA,CAFD,MAEO;kBACN2B,qBAAqB,GAAGY,WAAW,CAACvC,MAApC;kBACA4B,yBAAyB,GAAGO,MAA5B;gBACA;cACD,CAPD,MAOO;gBACNT,mBAAmB;gBACnBS,MAAI;gBACJR,qBAAqB,GAAG,CAACkB,eAAzB;gBACAjB,yBAAyB,GAAGO,MAA5B;cACA;YACD,CA/EC,CAiFF;;;YAAA;YACAX,aAAa,GAAGpB,IAAI,CAACwD,GAAL,CACfpC,aADe,EAEfpB,IAAI,CAACC,KAAL,CAAWkB,KAAK,CAACJ,CAAD,CAAL,CAASlC,GAAT,GAAe,CAA1B,CAFe,CAAhB,CAlFE,CAuFF;;YAAA;YACAkC,CAAC;YACDM,eAAe,GACdN,CAAC,GAAGI,KAAK,CAACvB,MAAV,GACGI,IAAI,CAACC,KAAL,CAAWkB,KAAK,CAACJ,CAAD,CAAL,CAASnC,KAApB,CADH,GAEGF,mBAHJ,CAzFE,CA8FF;;YAAA;YACA,IAAMwB,MAAM,GAAGqC,KAAK,CAAC3C,MAAN,GAAekD,MAAf,GAAwB1B,aAAxB,GAAwCyB,QAAvD;;YACA,IAAI3C,MAAM,GAAG,CAAb,EAAgB;cACf;cACA,IAAIkB,aAAa,IAAI0B,MAArB,EAA6B;gBAC5B,IAAIf,MAAI,GAAGS,aAAa,GAAGlB,mBAA3B;;gBACA,IAAIiB,KAAK,CAACQ,QAAN,CAAe,IAAf,CAAJ,EAA0B;kBACzBzB,mBAAmB;;kBACnB,IAAIE,yBAAyB,KAAKO,MAAlC,EAAwC;oBACvC;oBACAR,qBAAqB,IAAIkB,eAAzB;kBACA;gBACD,CAND,MAMO,IAAIjB,yBAAyB,KAAKO,MAAlC,EAAwC;kBAC9CR,qBAAqB,IAAIgB,KAAK,CAAC3C,MAAN,GAAeiD,QAAxC;gBACA,CAFM,MAEA;kBACNtB,qBAAqB,GAAGsB,QAAQ,GAAGN,KAAK,CAAC3C,MAAzC;kBACA4B,yBAAyB,GAAGO,MAA5B;gBACA;;gBACDpC,GAAG,GAAGmD,MAAN;gBACA;cACA,CAlBc,CAoBf;;;cAAA;cACA,IAAMf,MAAI,GAAGS,aAAa,GAAGlB,mBAA7B;;cACA,IACCO,oBAAoB,CACnBC,WADmB,EAEnBY,YAFmB,EAGnBC,cAHmB,EAInBJ,KAAK,CAACpC,KAAN,CAAY0C,QAAZ,EAAsBA,QAAQ,GAAG3C,MAAjC,CAJmB,CADrB,EAOE;gBACDyC,cAAc,IAAIzC,MAAlB;cACA;;cACD2C,QAAQ,IAAI3C,MAAZ;cACAP,GAAG,IAAIO,MAAP;;cACA,IAAIsB,yBAAyB,KAAKO,MAAlC,EAAwC;gBACvCR,qBAAqB,IAAIrB,MAAzB;cACA,CAFD,MAEO;gBACNqB,qBAAqB,GAAG,CAACrB,MAAzB;gBACAsB,yBAAyB,GAAGO,MAA5B;cACA;;cACDU,eAAe,IAAIvC,MAAnB;YACA;UACD,CA1ID,QA0ISmB,eAAe,GAAGyB,MA1I3B;QA2IA,CA7LG,CA+LJ;;;QAAA;QACA,IAAID,QAAQ,GAAGN,KAAK,CAAC3C,MAArB,EAA6B;UAC5B,IAAMoD,WAAU,GAAGH,QAAQ,KAAK,CAAb,GAAiBN,KAAjB,GAAyBA,KAAK,CAACpC,KAAN,CAAY0C,QAAZ,CAA5C;;UACA,IAAMd,MAAI,GAAGS,aAAa,GAAGlB,mBAA7B;;UACAN,OAAO,CACNgC,WADM,EAENjB,MAFM,EAGNU,eAAe,IACbV,MAAI,KAAKP,yBAAT,GAAqCD,qBAArC,GAA6D,CADhD,CAHT,EAKNO,WALM,EAMNY,YANM,EAONC,cAPM,EAQNC,SAAS,GAAG,CAAZ,GAAgB,CAAC,CAAjB,GAAqBhB,gBAAgB,CAACgB,SAAD,CAR/B,CAAP;QAUA;;QACDjD,GAAG,GAAGmD,MAAN;MACA,CA1NmD,EA2NpD,UAAChB,WAAD,EAAc5C,MAAd,EAAsBuE,aAAtB,EAAwC;QACvC,OAAOhC,cAAc,CAAC7B,MAAf,GAAwBkC,WAA/B;UACCL,cAAc,CAAC/B,IAAf,CAAoBwC,SAApB;QADD;;QAEAT,cAAc,CAACK,WAAD,CAAd,GAA8B2B,aAA9B;QACAxC,QAAQ,CAACa,WAAD,EAAc5C,MAAd,EAAsBuE,aAAtB,CAAR;MACA,CAhOmD,EAiOpD,UAACb,SAAD,EAAY7D,IAAZ,EAAqB;QACpB,IAAIoE,WAAW,GAAGzB,WAAW,CAAC0B,GAAZ,CAAgBrE,IAAhB,CAAlB;;QACA,IAAIoE,WAAW,KAAKjB,SAApB,EAA+B;UAC9BiB,WAAW,GAAGzB,WAAW,CAAC2B,IAA1B;UACA3B,WAAW,CAAC4B,GAAZ,CAAgBvE,IAAhB,EAAsBoE,WAAtB;UACAjC,MAAM,CAACiC,WAAD,EAAcpE,IAAd,CAAN;QACA;;QACD6C,gBAAgB,CAACgB,SAAD,CAAhB,GAA8BO,WAA9B;MACA,CAzOmD,CAArD;MAAA,IAAMX,aAAN,kBAAMA,aAAN;MAAA,IAAqBC,eAArB,kBAAqBA,eAArB,CA/BgD,CA2QhD;;;MACA,IAAIiB,QAAQ,GAAG,EAAf;;MACA,OAAO3C,CAAC,GAAGI,KAAK,CAACvB,MAAjB,EAAyBmB,CAAC,EAA1B,EAA8B;QAC7B2C,QAAQ,IAAIvC,KAAK,CAACJ,CAAD,CAAL,CAASjC,OAArB;MACA,CA/Q+C,CAiRhD;;;MACA,IAAIiD,IAAI,GAAGS,aAAa,GAAGlB,mBAA3B;MACA,IAAI2B,OAAO,GAAG7E,cAAc,CAACsF,QAAD,CAA5B;;MACA,KAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAAO,CAACrD,MAA5B,EAAoC2D,CAAC,EAArC,EAAyC;QACxC,IAAMpB,WAAW,GAAGc,OAAO,CAACM,CAAD,CAA3B;QACAvC,OAAO,CACNmB,WADM,EAENJ,IAFM,EAGNU,eAAe,IACbV,IAAI,KAAKP,yBAAT,GAAqCD,qBAArC,GAA6D,CADhD,CAHT,EAKN,CAAC,CALK,EAMN,CAAC,CANK,EAON,CAAC,CAPK,EAQN,CAAC,CARK,CAAP;;QAWA,IAAIgC,CAAC,KAAKN,OAAO,CAACrD,MAAR,GAAiB,CAAvB,IAA4B,CAACuC,WAAW,CAACY,QAAZ,CAAqB,IAArB,CAAjC,EAA6D;UAC5D,IAAIvB,yBAAyB,KAAKO,IAAlC,EAAwC;YACvCR,qBAAqB,IAAIY,WAAW,CAACvC,MAArC;UACA,CAFD,MAEO;YACN2B,qBAAqB,GAAGY,WAAW,CAACvC,MAApC;YACA4B,yBAAyB,GAAGO,IAA5B;UACA;QACD,CAPD,MAOO;UACNT,mBAAmB;UACnBS,IAAI;UACJR,qBAAqB,GAAG,CAACkB,eAAzB;UACAjB,yBAAyB,GAAGO,IAA5B;QACA;MACD;;MAED,OAAO;QACNS,aAAa,EAAET,IADT;QAENU,eAAe,EACdA,eAAe,IACdV,IAAI,KAAKP,yBAAT,GAAqCD,qBAArC,GAA6D,CAD/C;MAHV,CAAP;IAMA;;;WAED,oBAAWoC,IAAX,EAAiB;MAChB,KAAKpE,iBAAL;;MACAoE,IAAI,CAACC,MAAL,CAAY,eAAZ;;MACA,KAAKzE,OAAL,CAAa0E,UAAb,CAAwBF,IAAxB;;MACAA,IAAI,CAACC,MAAL,CAAY,KAAKxE,KAAL,IAAc,EAA1B;;MAJgB,4CAKG,KAAKC,aALR;MAAA;;MAAA;QAKhB,uDAAuC;UAAA,IAA5ByB,IAA4B;UACtC6C,IAAI,CAACC,MAAL,WAAe9C,IAAI,CAAClC,KAApB,SAA4BkC,IAAI,CAACjC,GAAjC,SAAuCiC,IAAI,CAAChC,OAA5C,SAAsDgC,IAAI,CAAC/B,IAA3D;QACA;MAPe;QAAA;MAAA;QAAA;MAAA;IAQhB;;;;EA9a0BZ,M;;AAib5B2F,MAAM,CAACC,OAAP,GAAiB9E,aAAjB"},"metadata":{},"sourceType":"script"}