{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.date.to-string.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n    getMap = _require.getMap,\n    getSourceAndMap = _require.getSourceAndMap;\n\nvar splitIntoLines = require(\"./helpers/splitIntoLines\");\n\nvar getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\n\nvar Source = require(\"./Source\");\n\nvar splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nvar OriginalSource = /*#__PURE__*/function (_Source) {\n  _inherits(OriginalSource, _Source);\n\n  var _super = _createSuper(OriginalSource);\n\n  function OriginalSource(value, name) {\n    var _this;\n\n    _classCallCheck(this, OriginalSource);\n\n    _this = _super.call(this);\n    var isBuffer = Buffer.isBuffer(value);\n    _this._value = isBuffer ? undefined : value;\n    _this._valueAsBuffer = isBuffer ? value : undefined;\n    _this._name = name;\n    return _this;\n  }\n\n  _createClass(OriginalSource, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (this._value === undefined) {\n        this._value = this._valueAsBuffer.toString(\"utf-8\");\n      }\n\n      return this._value;\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      if (this._valueAsBuffer === undefined) {\n        this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n      }\n\n      return this._valueAsBuffer;\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n    /**\n     * @param {object} options options\n     * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n     * @param {function(number, string, string)} onSource called for each source\n     * @param {function(number, string)} onName called for each name\n     * @returns {void}\n     */\n\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      if (this._value === undefined) {\n        this._value = this._valueAsBuffer.toString(\"utf-8\");\n      }\n\n      onSource(0, this._name, this._value);\n      var finalSource = !!(options && options.finalSource);\n\n      if (!options || options.columns !== false) {\n        // With column info we need to read all lines and split them\n        var matches = splitIntoPotentialTokens(this._value);\n        var line = 1;\n        var column = 0;\n\n        if (matches !== null) {\n          var _iterator = _createForOfIteratorHelper(matches),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var match = _step.value;\n              var isEndOfLine = match.endsWith(\"\\n\");\n\n              if (isEndOfLine && match.length === 1) {\n                if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n              } else {\n                var chunk = finalSource ? undefined : match;\n                onChunk(chunk, line, column, 0, line, column, -1);\n              }\n\n              if (isEndOfLine) {\n                line++;\n                column = 0;\n              } else {\n                column += match.length;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        return {\n          generatedLine: line,\n          generatedColumn: column,\n          source: finalSource ? this._value : undefined\n        };\n      } else if (finalSource) {\n        // Without column info and with final source we only\n        // need meta info to generate mapping\n        var result = getGeneratedSourceInfo(this._value);\n        var generatedLine = result.generatedLine,\n            generatedColumn = result.generatedColumn;\n\n        if (generatedColumn === 0) {\n          for (var _line = 1; _line < generatedLine; _line++) {\n            onChunk(undefined, _line, 0, 0, _line, 0, -1);\n          }\n        } else {\n          for (var _line2 = 1; _line2 <= generatedLine; _line2++) {\n            onChunk(undefined, _line2, 0, 0, _line2, 0, -1);\n          }\n        }\n\n        return result;\n      } else {\n        // Without column info, but also without final source\n        // we need to split source by lines\n        var _line3 = 1;\n\n        var _matches = splitIntoLines(this._value);\n\n        var _match;\n\n        var _iterator2 = _createForOfIteratorHelper(_matches),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            _match = _step2.value;\n            onChunk(finalSource ? undefined : _match, _line3, 0, 0, _line3, 0, -1);\n            _line3++;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return _matches.length === 0 || _match.endsWith(\"\\n\") ? {\n          generatedLine: _matches.length + 1,\n          generatedColumn: 0,\n          source: finalSource ? this._value : undefined\n        } : {\n          generatedLine: _matches.length,\n          generatedColumn: _match.length,\n          source: finalSource ? this._value : undefined\n        };\n      }\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (this._valueAsBuffer === undefined) {\n        this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n      }\n\n      hash.update(\"OriginalSource\");\n      hash.update(this._valueAsBuffer);\n      hash.update(this._name || \"\");\n    }\n  }]);\n\n  return OriginalSource;\n}(Source);\n\nmodule.exports = OriginalSource;","map":{"version":3,"names":["require","getMap","getSourceAndMap","splitIntoLines","getGeneratedSourceInfo","Source","splitIntoPotentialTokens","OriginalSource","value","name","isBuffer","Buffer","_value","undefined","_valueAsBuffer","_name","toString","from","options","onChunk","onSource","onName","finalSource","columns","matches","line","column","match","isEndOfLine","endsWith","length","chunk","generatedLine","generatedColumn","source","result","hash","update","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/webpack-sources/lib/OriginalSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\nconst Source = require(\"./Source\");\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nclass OriginalSource extends Source {\n\tconstructor(value, name) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tthis._value = isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._name = name;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\tonSource(0, this._name, this._value);\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tif (!options || options.columns !== false) {\n\t\t\t// With column info we need to read all lines and split them\n\t\t\tconst matches = splitIntoPotentialTokens(this._value);\n\t\t\tlet line = 1;\n\t\t\tlet column = 0;\n\t\t\tif (matches !== null) {\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst isEndOfLine = match.endsWith(\"\\n\");\n\t\t\t\t\tif (isEndOfLine && match.length === 1) {\n\t\t\t\t\t\tif (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst chunk = finalSource ? undefined : match;\n\t\t\t\t\t\tonChunk(chunk, line, column, 0, line, column, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (isEndOfLine) {\n\t\t\t\t\t\tline++;\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn += match.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tgeneratedLine: line,\n\t\t\t\tgeneratedColumn: column,\n\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t};\n\t\t} else if (finalSource) {\n\t\t\t// Without column info and with final source we only\n\t\t\t// need meta info to generate mapping\n\t\t\tconst result = getGeneratedSourceInfo(this._value);\n\t\t\tconst { generatedLine, generatedColumn } = result;\n\t\t\tif (generatedColumn === 0) {\n\t\t\t\tfor (let line = 1; line < generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t} else {\n\t\t\t\tfor (let line = 1; line <= generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// Without column info, but also without final source\n\t\t\t// we need to split source by lines\n\t\t\tlet line = 1;\n\t\t\tconst matches = splitIntoLines(this._value);\n\t\t\tlet match;\n\t\t\tfor (match of matches) {\n\t\t\t\tonChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n\t\t\t\tline++;\n\t\t\t}\n\t\t\treturn matches.length === 0 || match.endsWith(\"\\n\")\n\t\t\t\t? {\n\t\t\t\t\t\tgeneratedLine: matches.length + 1,\n\t\t\t\t\t\tgeneratedColumn: 0,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  }\n\t\t\t\t: {\n\t\t\t\t\t\tgeneratedLine: matches.length,\n\t\t\t\t\t\tgeneratedColumn: match.length,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  };\n\t\t}\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"OriginalSource\");\n\t\thash.update(this._valueAsBuffer);\n\t\thash.update(this._name || \"\");\n\t}\n}\n\nmodule.exports = OriginalSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}