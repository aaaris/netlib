{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/es.weak-set.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar Source = require(\"./Source\");\n\nvar RawSource = require(\"./RawSource\");\n\nvar _streamChunks = require(\"./helpers/streamChunks\");\n\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n    getMap = _require.getMap,\n    getSourceAndMap = _require.getSourceAndMap;\n\nvar stringsAsRawSources = new WeakSet();\n\nvar ConcatSource = /*#__PURE__*/function (_Source) {\n  _inherits(ConcatSource, _Source);\n\n  var _super = _createSuper(ConcatSource);\n\n  function ConcatSource() {\n    var _this;\n\n    _classCallCheck(this, ConcatSource);\n\n    _this = _super.call(this);\n    _this._children = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      var item = arguments[i];\n\n      if (item instanceof ConcatSource) {\n        var _iterator = _createForOfIteratorHelper(item._children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var child = _step.value;\n\n            _this._children.push(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        _this._children.push(item);\n      }\n    }\n\n    _this._isOptimized = arguments.length === 0;\n    return _this;\n  }\n\n  _createClass(ConcatSource, [{\n    key: \"getChildren\",\n    value: function getChildren() {\n      if (!this._isOptimized) this._optimize();\n      return this._children;\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      if (item instanceof ConcatSource) {\n        var _iterator2 = _createForOfIteratorHelper(item._children),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n\n            this._children.push(child);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        this._children.push(item);\n      }\n\n      this._isOptimized = false;\n    }\n  }, {\n    key: \"addAllSkipOptimizing\",\n    value: function addAllSkipOptimizing(items) {\n      var _iterator3 = _createForOfIteratorHelper(items),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n\n          this._children.push(item);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      if (!this._isOptimized) this._optimize();\n      var buffers = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this._children),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n\n          if (typeof child.buffer === \"function\") {\n            buffers.push(child.buffer());\n          } else {\n            var bufferOrString = child.source();\n\n            if (Buffer.isBuffer(bufferOrString)) {\n              buffers.push(bufferOrString);\n            } else {\n              // This will not happen\n              buffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return Buffer.concat(buffers);\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (!this._isOptimized) this._optimize();\n      var source = \"\";\n\n      var _iterator5 = _createForOfIteratorHelper(this._children),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n          source += child.source();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return source;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      if (!this._isOptimized) this._optimize();\n      var size = 0;\n\n      var _iterator6 = _createForOfIteratorHelper(this._children),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var child = _step6.value;\n          size += child.size();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return size;\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      if (!this._isOptimized) this._optimize();\n      if (this._children.length === 1) return this._children[0].streamChunks(options, onChunk, onSource, onName);\n      var currentLineOffset = 0;\n      var currentColumnOffset = 0;\n      var sourceMapping = new Map();\n      var nameMapping = new Map();\n      var finalSource = !!(options && options.finalSource);\n      var code = \"\";\n      var needToCloseMapping = false;\n\n      var _iterator7 = _createForOfIteratorHelper(this._children),\n          _step7;\n\n      try {\n        var _loop = function _loop() {\n          var item = _step7.value;\n          var sourceIndexMapping = [];\n          var nameIndexMapping = [];\n          var lastMappingLine = 0;\n\n          var _streamChunks2 = _streamChunks(item, options, // eslint-disable-next-line no-loop-func\n          function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n            var line = generatedLine + currentLineOffset;\n            var column = generatedLine === 1 ? generatedColumn + currentColumnOffset : generatedColumn;\n\n            if (needToCloseMapping) {\n              if (generatedLine !== 1 || generatedColumn !== 0) {\n                onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n              }\n\n              needToCloseMapping = false;\n            }\n\n            var resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n            var resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];\n            lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\n            if (finalSource) {\n              if (chunk !== undefined) code += chunk;\n\n              if (resultSourceIndex >= 0) {\n                onChunk(undefined, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n              }\n            } else {\n              if (resultSourceIndex < 0) {\n                onChunk(chunk, line, column, -1, -1, -1, -1);\n              } else {\n                onChunk(chunk, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n              }\n            }\n          }, function (i, source, sourceContent) {\n            var globalIndex = sourceMapping.get(source);\n\n            if (globalIndex === undefined) {\n              sourceMapping.set(source, globalIndex = sourceMapping.size);\n              onSource(globalIndex, source, sourceContent);\n            }\n\n            sourceIndexMapping[i] = globalIndex;\n          }, function (i, name) {\n            var globalIndex = nameMapping.get(name);\n\n            if (globalIndex === undefined) {\n              nameMapping.set(name, globalIndex = nameMapping.size);\n              onName(globalIndex, name);\n            }\n\n            nameIndexMapping[i] = globalIndex;\n          }),\n              generatedLine = _streamChunks2.generatedLine,\n              generatedColumn = _streamChunks2.generatedColumn,\n              source = _streamChunks2.source;\n\n          if (source !== undefined) code += source;\n\n          if (needToCloseMapping) {\n            if (generatedLine !== 1 || generatedColumn !== 0) {\n              onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n              needToCloseMapping = false;\n            }\n          }\n\n          if (generatedLine > 1) {\n            currentColumnOffset = generatedColumn;\n          } else {\n            currentColumnOffset += generatedColumn;\n          }\n\n          needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;\n          currentLineOffset += generatedLine - 1;\n        };\n\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return {\n        generatedLine: currentLineOffset + 1,\n        generatedColumn: currentColumnOffset,\n        source: finalSource ? code : undefined\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (!this._isOptimized) this._optimize();\n      hash.update(\"ConcatSource\");\n\n      var _iterator8 = _createForOfIteratorHelper(this._children),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var item = _step8.value;\n          item.updateHash(hash);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"_optimize\",\n    value: function _optimize() {\n      var newChildren = [];\n      var currentString = undefined;\n      var currentRawSources = undefined;\n\n      var addStringToRawSources = function addStringToRawSources(string) {\n        if (currentRawSources === undefined) {\n          currentRawSources = string;\n        } else if (Array.isArray(currentRawSources)) {\n          currentRawSources.push(string);\n        } else {\n          currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), string];\n        }\n      };\n\n      var addSourceToRawSources = function addSourceToRawSources(source) {\n        if (currentRawSources === undefined) {\n          currentRawSources = source;\n        } else if (Array.isArray(currentRawSources)) {\n          currentRawSources.push(source.source());\n        } else {\n          currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), source.source()];\n        }\n      };\n\n      var mergeRawSources = function mergeRawSources() {\n        if (Array.isArray(currentRawSources)) {\n          var rawSource = new RawSource(currentRawSources.join(\"\"));\n          stringsAsRawSources.add(rawSource);\n          newChildren.push(rawSource);\n        } else if (typeof currentRawSources === \"string\") {\n          var _rawSource = new RawSource(currentRawSources);\n\n          stringsAsRawSources.add(_rawSource);\n          newChildren.push(_rawSource);\n        } else {\n          newChildren.push(currentRawSources);\n        }\n      };\n\n      var _iterator9 = _createForOfIteratorHelper(this._children),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var child = _step9.value;\n\n          if (typeof child === \"string\") {\n            if (currentString === undefined) {\n              currentString = child;\n            } else {\n              currentString += child;\n            }\n          } else {\n            if (currentString !== undefined) {\n              addStringToRawSources(currentString);\n              currentString = undefined;\n            }\n\n            if (stringsAsRawSources.has(child)) {\n              addSourceToRawSources(child);\n            } else {\n              if (currentRawSources !== undefined) {\n                mergeRawSources();\n                currentRawSources = undefined;\n              }\n\n              newChildren.push(child);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      if (currentString !== undefined) {\n        addStringToRawSources(currentString);\n      }\n\n      if (currentRawSources !== undefined) {\n        mergeRawSources();\n      }\n\n      this._children = newChildren;\n      this._isOptimized = true;\n    }\n  }]);\n\n  return ConcatSource;\n}(Source);\n\nmodule.exports = ConcatSource;","map":{"version":3,"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","stringsAsRawSources","WeakSet","ConcatSource","_children","i","arguments","length","item","child","push","_isOptimized","_optimize","items","buffers","buffer","bufferOrString","source","Buffer","isBuffer","from","concat","size","options","onChunk","onSource","onName","currentLineOffset","currentColumnOffset","sourceMapping","Map","nameMapping","finalSource","code","needToCloseMapping","sourceIndexMapping","nameIndexMapping","lastMappingLine","chunk","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","line","column","undefined","resultSourceIndex","resultNameIndex","sourceContent","globalIndex","get","set","name","hash","update","updateHash","newChildren","currentString","currentRawSources","addStringToRawSources","string","Array","isArray","addSourceToRawSources","mergeRawSources","rawSource","join","add","has","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/webpack-sources/lib/ConcatSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._children = [];\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tconst item = arguments[i];\n\t\t\tif (item instanceof ConcatSource) {\n\t\t\t\tfor (const child of item._children) {\n\t\t\t\t\tthis._children.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._children.push(item);\n\t\t\t}\n\t\t}\n\t\tthis._isOptimized = arguments.length === 0;\n\t}\n\n\tgetChildren() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\treturn this._children;\n\t}\n\n\tadd(item) {\n\t\tif (item instanceof ConcatSource) {\n\t\t\tfor (const child of item._children) {\n\t\t\t\tthis._children.push(child);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._children.push(item);\n\t\t}\n\t\tthis._isOptimized = false;\n\t}\n\n\taddAllSkipOptimizing(items) {\n\t\tfor (const item of items) {\n\t\t\tthis._children.push(item);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tconst buffers = [];\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child.buffer === \"function\") {\n\t\t\t\tbuffers.push(child.buffer());\n\t\t\t} else {\n\t\t\t\tconst bufferOrString = child.source();\n\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\tbuffers.push(bufferOrString);\n\t\t\t\t} else {\n\t\t\t\t\t// This will not happen\n\t\t\t\t\tbuffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Buffer.concat(buffers);\n\t}\n\n\tsource() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet source = \"\";\n\t\tfor (const child of this._children) {\n\t\t\tsource += child.source();\n\t\t}\n\t\treturn source;\n\t}\n\n\tsize() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet size = 0;\n\t\tfor (const child of this._children) {\n\t\t\tsize += child.size();\n\t\t}\n\t\treturn size;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tif (this._children.length === 1)\n\t\t\treturn this._children[0].streamChunks(options, onChunk, onSource, onName);\n\t\tlet currentLineOffset = 0;\n\t\tlet currentColumnOffset = 0;\n\t\tlet sourceMapping = new Map();\n\t\tlet nameMapping = new Map();\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tlet code = \"\";\n\t\tlet needToCloseMapping = false;\n\t\tfor (const item of this._children) {\n\t\t\tconst sourceIndexMapping = [];\n\t\t\tconst nameIndexMapping = [];\n\t\t\tlet lastMappingLine = 0;\n\t\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\t\titem,\n\t\t\t\toptions,\n\t\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\t\t(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t) => {\n\t\t\t\t\tconst line = generatedLine + currentLineOffset;\n\t\t\t\t\tconst column =\n\t\t\t\t\t\tgeneratedLine === 1\n\t\t\t\t\t\t\t? generatedColumn + currentColumnOffset\n\t\t\t\t\t\t\t: generatedColumn;\n\t\t\t\t\tif (needToCloseMapping) {\n\t\t\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t\t}\n\t\t\t\t\tconst resultSourceIndex =\n\t\t\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\t\t\tconst resultNameIndex =\n\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: nameIndexMapping[nameIndex];\n\t\t\t\t\tlastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\t\t\t\t\tif (finalSource) {\n\t\t\t\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\t\t\t\tif (resultSourceIndex >= 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (resultSourceIndex < 0) {\n\t\t\t\t\t\t\tonChunk(chunk, line, column, -1, -1, -1, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t\t},\n\t\t\t\t(i, name) => {\n\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t}\n\t\t\t\t\tnameIndexMapping[i] = globalIndex;\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (source !== undefined) code += source;\n\t\t\tif (needToCloseMapping) {\n\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1\n\t\t\t\t\t);\n\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (generatedLine > 1) {\n\t\t\t\tcurrentColumnOffset = generatedColumn;\n\t\t\t} else {\n\t\t\t\tcurrentColumnOffset += generatedColumn;\n\t\t\t}\n\t\t\tneedToCloseMapping =\n\t\t\t\tneedToCloseMapping ||\n\t\t\t\t(finalSource && lastMappingLine === generatedLine);\n\t\t\tcurrentLineOffset += generatedLine - 1;\n\t\t}\n\t\treturn {\n\t\t\tgeneratedLine: currentLineOffset + 1,\n\t\t\tgeneratedColumn: currentColumnOffset,\n\t\t\tsource: finalSource ? code : undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\thash.update(\"ConcatSource\");\n\t\tfor (const item of this._children) {\n\t\t\titem.updateHash(hash);\n\t\t}\n\t}\n\n\t_optimize() {\n\t\tconst newChildren = [];\n\t\tlet currentString = undefined;\n\t\tlet currentRawSources = undefined;\n\t\tconst addStringToRawSources = string => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = string;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(string);\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tstring\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst addSourceToRawSources = source => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = source;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(source.source());\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tsource.source()\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst mergeRawSources = () => {\n\t\t\tif (Array.isArray(currentRawSources)) {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources.join(\"\"));\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else if (typeof currentRawSources === \"string\") {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources);\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else {\n\t\t\t\tnewChildren.push(currentRawSources);\n\t\t\t}\n\t\t};\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child === \"string\") {\n\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\tcurrentString = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentString += child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\taddStringToRawSources(currentString);\n\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t}\n\t\t\t\tif (stringsAsRawSources.has(child)) {\n\t\t\t\t\taddSourceToRawSources(child);\n\t\t\t\t} else {\n\t\t\t\t\tif (currentRawSources !== undefined) {\n\t\t\t\t\t\tmergeRawSources();\n\t\t\t\t\t\tcurrentRawSources = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentString !== undefined) {\n\t\t\taddStringToRawSources(currentString);\n\t\t}\n\t\tif (currentRawSources !== undefined) {\n\t\t\tmergeRawSources();\n\t\t}\n\t\tthis._children = newChildren;\n\t\tthis._isOptimized = true;\n\t}\n}\n\nmodule.exports = ConcatSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}