{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"events\"),\n    EventEmitter = _require.EventEmitter;\n\nvar reducePlan = require(\"./reducePlan\");\n\nvar IS_OSX = require(\"os\").platform() === \"darwin\";\nvar IS_WIN = require(\"os\").platform() === \"win32\";\nvar SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\nvar watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\nvar recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\nvar isBatch = false;\nvar watcherCount = 0;\n/** @type {Map<Watcher, string>} */\n\nvar pendingWatchers = new Map();\n/** @type {Map<string, RecursiveWatcher>} */\n\nvar recursiveWatchers = new Map();\n/** @type {Map<string, DirectWatcher>} */\n\nvar directWatchers = new Map();\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\n\nvar underlyingWatcher = new Map();\n\nvar DirectWatcher = /*#__PURE__*/function () {\n  function DirectWatcher(filePath) {\n    var _this = this;\n\n    _classCallCheck(this, DirectWatcher);\n\n    this.filePath = filePath;\n    this.watchers = new Set();\n    this.watcher = undefined;\n\n    try {\n      var watcher = fs.watch(filePath);\n      this.watcher = watcher;\n      watcher.on(\"change\", function (type, filename) {\n        var _iterator = _createForOfIteratorHelper(_this.watchers),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var w = _step.value;\n            w.emit(\"change\", type, filename);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n      watcher.on(\"error\", function (error) {\n        var _iterator2 = _createForOfIteratorHelper(_this.watchers),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var w = _step2.value;\n            w.emit(\"error\", error);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n    } catch (err) {\n      process.nextTick(function () {\n        var _iterator3 = _createForOfIteratorHelper(_this.watchers),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var w = _step3.value;\n            w.emit(\"error\", err);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      });\n    }\n\n    watcherCount++;\n  }\n\n  _createClass(DirectWatcher, [{\n    key: \"add\",\n    value: function add(watcher) {\n      underlyingWatcher.set(watcher, this);\n      this.watchers.add(watcher);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(watcher) {\n      this.watchers[\"delete\"](watcher);\n\n      if (this.watchers.size === 0) {\n        directWatchers[\"delete\"](this.filePath);\n        watcherCount--;\n        if (this.watcher) this.watcher.close();\n      }\n    }\n  }, {\n    key: \"getWatchers\",\n    value: function getWatchers() {\n      return this.watchers;\n    }\n  }]);\n\n  return DirectWatcher;\n}();\n\nvar RecursiveWatcher = /*#__PURE__*/function () {\n  function RecursiveWatcher(rootPath) {\n    var _this2 = this;\n\n    _classCallCheck(this, RecursiveWatcher);\n\n    this.rootPath = rootPath;\n    /** @type {Map<Watcher, string>} */\n\n    this.mapWatcherToPath = new Map();\n    /** @type {Map<string, Set<Watcher>>} */\n\n    this.mapPathToWatchers = new Map();\n    this.watcher = undefined;\n\n    try {\n      var watcher = fs.watch(rootPath, {\n        recursive: true\n      });\n      this.watcher = watcher;\n      watcher.on(\"change\", function (type, filename) {\n        if (!filename) {\n          if (recursiveWatcherLogging) {\n            process.stderr.write(\"[watchpack] dispatch \".concat(type, \" event in recursive watcher (\").concat(_this2.rootPath, \") to all watchers\\n\"));\n          }\n\n          var _iterator4 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var w = _step4.value;\n              w.emit(\"change\", type);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          var dir = path.dirname(filename);\n\n          var watchers = _this2.mapPathToWatchers.get(dir);\n\n          if (recursiveWatcherLogging) {\n            process.stderr.write(\"[watchpack] dispatch \".concat(type, \" event in recursive watcher (\").concat(_this2.rootPath, \") for '\").concat(filename, \"' to \").concat(watchers ? watchers.size : 0, \" watchers\\n\"));\n          }\n\n          if (watchers === undefined) return;\n\n          var _iterator5 = _createForOfIteratorHelper(watchers),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _w = _step5.value;\n\n              _w.emit(\"change\", type, path.basename(filename));\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      });\n      watcher.on(\"error\", function (error) {\n        var _iterator6 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var w = _step6.value;\n            w.emit(\"error\", error);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      });\n    } catch (err) {\n      process.nextTick(function () {\n        var _iterator7 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var w = _step7.value;\n            w.emit(\"error\", err);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      });\n    }\n\n    watcherCount++;\n\n    if (recursiveWatcherLogging) {\n      process.stderr.write(\"[watchpack] created recursive watcher at \".concat(rootPath, \"\\n\"));\n    }\n  }\n\n  _createClass(RecursiveWatcher, [{\n    key: \"add\",\n    value: function add(filePath, watcher) {\n      underlyingWatcher.set(watcher, this);\n      var subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n      this.mapWatcherToPath.set(watcher, subpath);\n      var set = this.mapPathToWatchers.get(subpath);\n\n      if (set === undefined) {\n        var newSet = new Set();\n        newSet.add(watcher);\n        this.mapPathToWatchers.set(subpath, newSet);\n      } else {\n        set.add(watcher);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(watcher) {\n      var subpath = this.mapWatcherToPath.get(watcher);\n      if (!subpath) return;\n      this.mapWatcherToPath[\"delete\"](watcher);\n      var set = this.mapPathToWatchers.get(subpath);\n      set[\"delete\"](watcher);\n\n      if (set.size === 0) {\n        this.mapPathToWatchers[\"delete\"](subpath);\n      }\n\n      if (this.mapWatcherToPath.size === 0) {\n        recursiveWatchers[\"delete\"](this.rootPath);\n        watcherCount--;\n        if (this.watcher) this.watcher.close();\n\n        if (recursiveWatcherLogging) {\n          process.stderr.write(\"[watchpack] closed recursive watcher at \".concat(this.rootPath, \"\\n\"));\n        }\n      }\n    }\n  }, {\n    key: \"getWatchers\",\n    value: function getWatchers() {\n      return this.mapWatcherToPath;\n    }\n  }]);\n\n  return RecursiveWatcher;\n}();\n\nvar Watcher = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Watcher, _EventEmitter);\n\n  var _super = _createSuper(Watcher);\n\n  function Watcher() {\n    _classCallCheck(this, Watcher);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Watcher, [{\n    key: \"close\",\n    value: function close() {\n      if (pendingWatchers.has(this)) {\n        pendingWatchers[\"delete\"](this);\n        return;\n      }\n\n      var watcher = underlyingWatcher.get(this);\n      watcher.remove(this);\n      underlyingWatcher[\"delete\"](this);\n    }\n  }]);\n\n  return Watcher;\n}(EventEmitter);\n\nvar createDirectWatcher = function createDirectWatcher(filePath) {\n  var existing = directWatchers.get(filePath);\n  if (existing !== undefined) return existing;\n  var w = new DirectWatcher(filePath);\n  directWatchers.set(filePath, w);\n  return w;\n};\n\nvar createRecursiveWatcher = function createRecursiveWatcher(rootPath) {\n  var existing = recursiveWatchers.get(rootPath);\n  if (existing !== undefined) return existing;\n  var w = new RecursiveWatcher(rootPath);\n  recursiveWatchers.set(rootPath, w);\n  return w;\n};\n\nvar execute = function execute() {\n  /** @type {Map<string, Watcher[] | Watcher>} */\n  var map = new Map();\n\n  var addWatcher = function addWatcher(watcher, filePath) {\n    var entry = map.get(filePath);\n\n    if (entry === undefined) {\n      map.set(filePath, watcher);\n    } else if (Array.isArray(entry)) {\n      entry.push(watcher);\n    } else {\n      map.set(filePath, [entry, watcher]);\n    }\n  };\n\n  var _iterator8 = _createForOfIteratorHelper(pendingWatchers),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _step8$value = _slicedToArray(_step8.value, 2),\n          watcher = _step8$value[0],\n          _filePath = _step8$value[1];\n\n      addWatcher(watcher, _filePath);\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  pendingWatchers.clear(); // Fast case when we are not reaching the limit\n\n  if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n    // Create watchers for all entries in the map\n    var _iterator9 = _createForOfIteratorHelper(map),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n            filePath = _step9$value[0],\n            entry = _step9$value[1];\n\n        var w = createDirectWatcher(filePath);\n\n        if (Array.isArray(entry)) {\n          var _iterator10 = _createForOfIteratorHelper(entry),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var item = _step10.value;\n              w.add(item);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        } else {\n          w.add(entry);\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return;\n  } // Reconsider existing watchers to improving watch plan\n\n\n  var _iterator11 = _createForOfIteratorHelper(recursiveWatchers.values()),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _watcher = _step11.value;\n\n      var _iterator14 = _createForOfIteratorHelper(_watcher.getWatchers()),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _step14$value = _slicedToArray(_step14.value, 2),\n              _w2 = _step14$value[0],\n              subpath = _step14$value[1];\n\n          addWatcher(_w2, path.join(_watcher.rootPath, subpath));\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(directWatchers.values()),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var _watcher2 = _step12.value;\n\n      var _iterator15 = _createForOfIteratorHelper(_watcher2.getWatchers()),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _w3 = _step15.value;\n          addWatcher(_w3, _watcher2.filePath);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    } // Merge map entries to keep watcher limit\n    // Create a 10% buffer to be able to enter fast case more often\n\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  var plan = reducePlan(map, watcherLimit * 0.9); // Update watchers for all entries in the map\n\n  var _iterator13 = _createForOfIteratorHelper(plan),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var _step13$value = _slicedToArray(_step13.value, 2),\n          _filePath2 = _step13$value[0],\n          _entry = _step13$value[1];\n\n      if (_entry.size === 1) {\n        var _iterator16 = _createForOfIteratorHelper(_entry),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var _step16$value = _slicedToArray(_step16.value, 2),\n                _watcher3 = _step16$value[0],\n                _filePath3 = _step16$value[1];\n\n            var _w4 = createDirectWatcher(_filePath3);\n\n            var old = underlyingWatcher.get(_watcher3);\n            if (old === _w4) continue;\n\n            _w4.add(_watcher3);\n\n            if (old !== undefined) old.remove(_watcher3);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      } else {\n        var filePaths = new Set(_entry.values());\n\n        if (filePaths.size > 1) {\n          var _w5 = createRecursiveWatcher(_filePath2);\n\n          var _iterator17 = _createForOfIteratorHelper(_entry),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _step17$value = _slicedToArray(_step17.value, 2),\n                  _watcher4 = _step17$value[0],\n                  watcherPath = _step17$value[1];\n\n              var _old = underlyingWatcher.get(_watcher4);\n\n              if (_old === _w5) continue;\n\n              _w5.add(watcherPath, _watcher4);\n\n              if (_old !== undefined) _old.remove(_watcher4);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        } else {\n          var _iterator18 = _createForOfIteratorHelper(filePaths),\n              _step18;\n\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var _filePath4 = _step18.value;\n\n              var _w6 = createDirectWatcher(_filePath4);\n\n              var _iterator19 = _createForOfIteratorHelper(_entry.keys()),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var _watcher5 = _step19.value;\n\n                  var _old2 = underlyingWatcher.get(_watcher5);\n\n                  if (_old2 === _w6) continue;\n\n                  _w6.add(_watcher5);\n\n                  if (_old2 !== undefined) _old2.remove(_watcher5);\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n};\n\nexports.watch = function (filePath) {\n  var watcher = new Watcher(); // Find an existing watcher\n\n  var directWatcher = directWatchers.get(filePath);\n\n  if (directWatcher !== undefined) {\n    directWatcher.add(watcher);\n    return watcher;\n  }\n\n  var current = filePath;\n\n  for (;;) {\n    var recursiveWatcher = recursiveWatchers.get(current);\n\n    if (recursiveWatcher !== undefined) {\n      recursiveWatcher.add(filePath, watcher);\n      return watcher;\n    }\n\n    var parent = path.dirname(current);\n    if (parent === current) break;\n    current = parent;\n  } // Queue up watcher for creation\n\n\n  pendingWatchers.set(watcher, filePath);\n  if (!isBatch) execute();\n  return watcher;\n};\n\nexports.batch = function (fn) {\n  isBatch = true;\n\n  try {\n    fn();\n  } finally {\n    isBatch = false;\n    execute();\n  }\n};\n\nexports.getNumberOfWatchers = function () {\n  return watcherCount;\n};","map":{"version":3,"names":["fs","require","path","EventEmitter","reducePlan","IS_OSX","platform","IS_WIN","SUPPORTS_RECURSIVE_WATCHING","watcherLimit","process","env","WATCHPACK_WATCHER_LIMIT","recursiveWatcherLogging","WATCHPACK_RECURSIVE_WATCHER_LOGGING","isBatch","watcherCount","pendingWatchers","Map","recursiveWatchers","directWatchers","underlyingWatcher","DirectWatcher","filePath","watchers","Set","watcher","undefined","watch","on","type","filename","w","emit","error","err","nextTick","set","add","size","close","RecursiveWatcher","rootPath","mapWatcherToPath","mapPathToWatchers","recursive","stderr","write","keys","dir","dirname","get","basename","subpath","slice","length","newSet","Watcher","has","remove","createDirectWatcher","existing","createRecursiveWatcher","execute","map","addWatcher","entry","Array","isArray","push","clear","item","values","getWatchers","join","plan","old","filePaths","watcherPath","exports","directWatcher","current","recursiveWatcher","parent","batch","fn","getNumberOfWatchers"],"sources":["D:/Work/Project/LMS/lms/node_modules/watchpack/lib/watchEventSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { EventEmitter } = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\n\nconst watcherLimit =\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\n\nconst recursiveWatcherLogging = !!process.env\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\n\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n\tconstructor(filePath) {\n\t\tthis.filePath = filePath;\n\t\tthis.watchers = new Set();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(filePath);\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"change\", type, filename);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t}\n\n\tadd(watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tthis.watchers.add(watcher);\n\t}\n\n\tremove(watcher) {\n\t\tthis.watchers.delete(watcher);\n\t\tif (this.watchers.size === 0) {\n\t\t\tdirectWatchers.delete(this.filePath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.watchers;\n\t}\n}\n\nclass RecursiveWatcher {\n\tconstructor(rootPath) {\n\t\tthis.rootPath = rootPath;\n\t\t/** @type {Map<Watcher, string>} */\n\t\tthis.mapWatcherToPath = new Map();\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.mapPathToWatchers = new Map();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(rootPath, {\n\t\t\t\trecursive: true\n\t\t\t});\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tif (!filename) {\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) to all watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\t\tw.emit(\"change\", type);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = path.dirname(filename);\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) for '${filename}' to ${\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\n\t\t\t\t\t\t\t} watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (watchers === undefined) return;\n\t\t\t\t\tfor (const w of watchers) {\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t\tif (recursiveWatcherLogging) {\n\t\t\tprocess.stderr.write(\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\n\t\t\t);\n\t\t}\n\t}\n\n\tadd(filePath, watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tif (set === undefined) {\n\t\t\tconst newSet = new Set();\n\t\t\tnewSet.add(watcher);\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\n\t\t} else {\n\t\t\tset.add(watcher);\n\t\t}\n\t}\n\n\tremove(watcher) {\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\n\t\tif (!subpath) return;\n\t\tthis.mapWatcherToPath.delete(watcher);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tset.delete(watcher);\n\t\tif (set.size === 0) {\n\t\t\tthis.mapPathToWatchers.delete(subpath);\n\t\t}\n\t\tif (this.mapWatcherToPath.size === 0) {\n\t\t\trecursiveWatchers.delete(this.rootPath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.mapWatcherToPath;\n\t}\n}\n\nclass Watcher extends EventEmitter {\n\tclose() {\n\t\tif (pendingWatchers.has(this)) {\n\t\t\tpendingWatchers.delete(this);\n\t\t\treturn;\n\t\t}\n\t\tconst watcher = underlyingWatcher.get(this);\n\t\twatcher.remove(this);\n\t\tunderlyingWatcher.delete(this);\n\t}\n}\n\nconst createDirectWatcher = filePath => {\n\tconst existing = directWatchers.get(filePath);\n\tif (existing !== undefined) return existing;\n\tconst w = new DirectWatcher(filePath);\n\tdirectWatchers.set(filePath, w);\n\treturn w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n\tconst existing = recursiveWatchers.get(rootPath);\n\tif (existing !== undefined) return existing;\n\tconst w = new RecursiveWatcher(rootPath);\n\trecursiveWatchers.set(rootPath, w);\n\treturn w;\n};\n\nconst execute = () => {\n\t/** @type {Map<string, Watcher[] | Watcher>} */\n\tconst map = new Map();\n\tconst addWatcher = (watcher, filePath) => {\n\t\tconst entry = map.get(filePath);\n\t\tif (entry === undefined) {\n\t\t\tmap.set(filePath, watcher);\n\t\t} else if (Array.isArray(entry)) {\n\t\t\tentry.push(watcher);\n\t\t} else {\n\t\t\tmap.set(filePath, [entry, watcher]);\n\t\t}\n\t};\n\tfor (const [watcher, filePath] of pendingWatchers) {\n\t\taddWatcher(watcher, filePath);\n\t}\n\tpendingWatchers.clear();\n\n\t// Fast case when we are not reaching the limit\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n\t\t// Create watchers for all entries in the map\n\t\tfor (const [filePath, entry] of map) {\n\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\tif (Array.isArray(entry)) {\n\t\t\t\tfor (const item of entry) w.add(item);\n\t\t\t} else {\n\t\t\t\tw.add(entry);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Reconsider existing watchers to improving watch plan\n\tfor (const watcher of recursiveWatchers.values()) {\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\n\t\t}\n\t}\n\tfor (const watcher of directWatchers.values()) {\n\t\tfor (const w of watcher.getWatchers()) {\n\t\t\taddWatcher(w, watcher.filePath);\n\t\t}\n\t}\n\n\t// Merge map entries to keep watcher limit\n\t// Create a 10% buffer to be able to enter fast case more often\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\n\n\t// Update watchers for all entries in the map\n\tfor (const [filePath, entry] of plan) {\n\t\tif (entry.size === 1) {\n\t\t\tfor (const [watcher, filePath] of entry) {\n\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\tif (old === w) continue;\n\t\t\t\tw.add(watcher);\n\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t}\n\t\t} else {\n\t\t\tconst filePaths = new Set(entry.values());\n\t\t\tif (filePaths.size > 1) {\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\tw.add(watcherPath, watcher);\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const filePath of filePaths) {\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\t\tfor (const watcher of entry.keys()) {\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\t\tw.add(watcher);\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.watch = filePath => {\n\tconst watcher = new Watcher();\n\t// Find an existing watcher\n\tconst directWatcher = directWatchers.get(filePath);\n\tif (directWatcher !== undefined) {\n\t\tdirectWatcher.add(watcher);\n\t\treturn watcher;\n\t}\n\tlet current = filePath;\n\tfor (;;) {\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\n\t\tif (recursiveWatcher !== undefined) {\n\t\t\trecursiveWatcher.add(filePath, watcher);\n\t\t\treturn watcher;\n\t\t}\n\t\tconst parent = path.dirname(current);\n\t\tif (parent === current) break;\n\t\tcurrent = parent;\n\t}\n\t// Queue up watcher for creation\n\tpendingWatchers.set(watcher, filePath);\n\tif (!isBatch) execute();\n\treturn watcher;\n};\n\nexports.batch = fn => {\n\tisBatch = true;\n\ttry {\n\t\tfn();\n\t} finally {\n\t\tisBatch = false;\n\t\texecute();\n\t}\n};\n\nexports.getNumberOfWatchers = () => {\n\treturn watcherCount;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}