{"ast":null,"code":"'use strict';\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _assertThisInitialized = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/assertThisInitialized.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nvar _wrapNativeSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.date.to-string.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.symbol.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.json.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.math.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nvar hexify = function hexify(_char) {\n  var h = _char.charCodeAt(0).toString(16).toUpperCase();\n\n  return '0x' + (h.length % 2 ? '0' : '') + h;\n};\n\nvar parseError = function parseError(e, txt, context) {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0\n    };\n  }\n\n  var badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i);\n  var errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;\n  var msg = badToken ? e.message.replace(/^Unexpected token ./, \"Unexpected token \".concat(JSON.stringify(badToken[1]), \" (\").concat(hexify(badToken[1]), \")\")) : e.message;\n\n  if (errIdx !== null && errIdx !== undefined) {\n    var start = errIdx <= context ? 0 : errIdx - context;\n    var end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n    var slice = (start === 0 ? '' : '...') + txt.slice(start, end) + (end === txt.length ? '' : '...');\n    var near = txt === slice ? '' : 'near ';\n    return {\n      message: msg + \" while parsing \".concat(near).concat(JSON.stringify(slice)),\n      position: errIdx\n    };\n  } else {\n    return {\n      message: msg + \" while parsing '\".concat(txt.slice(0, context * 2), \"'\"),\n      position: 0\n    };\n  }\n};\n\nvar JSONParseError = /*#__PURE__*/function (_SyntaxError, _Symbol$toStringTag) {\n  _inherits(JSONParseError, _SyntaxError);\n\n  var _super = _createSuper(JSONParseError);\n\n  function JSONParseError(er, txt, context, caller) {\n    var _this;\n\n    _classCallCheck(this, JSONParseError);\n\n    context = context || 20;\n    var metadata = parseError(er, txt, context);\n    _this = _super.call(this, metadata.message);\n    Object.assign(_assertThisInitialized(_this), metadata);\n    _this.code = 'EJSONPARSE';\n    _this.systemError = er;\n    Error.captureStackTrace(_assertThisInitialized(_this), caller || _this.constructor);\n    return _this;\n  }\n\n  _createClass(JSONParseError, [{\n    key: \"name\",\n    get: function get() {\n      return this.constructor.name;\n    },\n    set: function set(n) {}\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return this.constructor.name;\n    }\n  }]);\n\n  return JSONParseError;\n}( /*#__PURE__*/_wrapNativeSuper(SyntaxError), Symbol.toStringTag);\n\nvar kIndent = Symbol[\"for\"]('indent');\nvar kNewline = Symbol[\"for\"]('newline'); // only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\n\nvar formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/;\nvar emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/;\n\nvar parseJson = function parseJson(txt, reviver, context) {\n  var parseText = stripBOM(txt);\n  context = context || 20;\n\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    var _ref = parseText.match(emptyRE) || parseText.match(formatRE) || [, '', ''],\n        _ref2 = _slicedToArray(_ref, 3),\n        _ref2$ = _ref2[1],\n        newline = _ref2$ === void 0 ? '\\n' : _ref2$,\n        _ref2$2 = _ref2[2],\n        indent = _ref2$2 === void 0 ? '  ' : _ref2$2;\n\n    var result = JSON.parse(parseText, reviver);\n\n    if (result && _typeof(result) === 'object') {\n      result[kNewline] = newline;\n      result[kIndent] = indent;\n    }\n\n    return result;\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      var isEmptyArray = Array.isArray(txt) && txt.length === 0;\n      throw Object.assign(new TypeError(\"Cannot parse \".concat(isEmptyArray ? 'an empty array' : String(txt))), {\n        code: 'EJSONPARSE',\n        systemError: e\n      });\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson);\n  }\n}; // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\n\n\nvar stripBOM = function stripBOM(txt) {\n  return String(txt).replace(/^\\uFEFF/, '');\n};\n\nmodule.exports = parseJson;\nparseJson.JSONParseError = JSONParseError;\n\nparseJson.noExceptions = function (txt, reviver) {\n  try {\n    return JSON.parse(stripBOM(txt), reviver);\n  } catch (e) {}\n};","map":{"version":3,"names":["hexify","char","h","charCodeAt","toString","toUpperCase","length","parseError","e","txt","context","message","position","badToken","match","errIdx","msg","replace","JSON","stringify","undefined","start","end","slice","near","JSONParseError","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","constructor","name","n","SyntaxError","Symbol","toStringTag","kIndent","kNewline","formatRE","emptyRE","parseJson","reviver","parseText","stripBOM","newline","indent","result","parse","Buffer","isBuffer","isEmptyArray","Array","isArray","TypeError","String","module","exports","noExceptions"],"sources":["D:/Work/Project/LMS/lms/node_modules/json-parse-even-better-errors/index.js"],"sourcesContent":["'use strict'\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return '0x' + (h.length % 2 ? '0' : '') + h\n}\n\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0,\n    }\n  }\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i)\n  const errIdx = badToken ? +badToken[2]\n    : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1\n    : null\n\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${\n      JSON.stringify(badToken[1])\n    } (${hexify(badToken[1])})`)\n    : e.message\n\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0\n      : errIdx - context\n\n    const end = errIdx + context >= txt.length ? txt.length\n      : errIdx + context\n\n    const slice = (start === 0 ? '' : '...') +\n      txt.slice(start, end) +\n      (end === txt.length ? '' : '...')\n\n    const near = txt === slice ? '' : 'near '\n\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx,\n    }\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0,\n    }\n  }\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    context = context || 20\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () { return this.constructor.name }\n  set name (n) {}\n  get [Symbol.toStringTag] () { return this.constructor.name }\n}\n\nconst kIndent = Symbol.for('indent')\nconst kNewline = Symbol.for('newline')\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt)\n  context = context || 20\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) ||\n      parseText.match(formatRE) ||\n      [, '', '']\n\n    const result = JSON.parse(parseText, reviver)\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline\n      result[kIndent] = indent\n    }\n    return result\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      throw Object.assign(new TypeError(\n        `Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`\n      ), {\n        code: 'EJSONPARSE',\n        systemError: e,\n      })\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson)\n  }\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '')\n\nmodule.exports = parseJson\nparseJson.JSONParseError = JSONParseError\n\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver)\n  } catch (e) {}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}