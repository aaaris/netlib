{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nvar path = require(\"path\");\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\n\n\nmodule.exports = function (plan, limit) {\n  var treeMap = new Map(); // Convert to tree\n\n  var _iterator = _createForOfIteratorHelper(plan),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          filePath = _step$value[0],\n          value = _step$value[1];\n\n      treeMap.set(filePath, {\n        filePath: filePath,\n        parent: undefined,\n        children: undefined,\n        entries: 1,\n        active: true,\n        value: value\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var currentCount = treeMap.size; // Create parents and calculate sum of entries\n\n  var _iterator2 = _createForOfIteratorHelper(treeMap.values()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _node2 = _step2.value;\n      var parentPath = path.dirname(_node2.filePath);\n\n      if (parentPath !== _node2.filePath) {\n        var _parent = treeMap.get(parentPath);\n\n        if (_parent === undefined) {\n          _parent = {\n            filePath: parentPath,\n            parent: undefined,\n            children: [_node2],\n            entries: _node2.entries,\n            active: false,\n            value: undefined\n          };\n          treeMap.set(parentPath, _parent);\n          _node2.parent = _parent;\n        } else {\n          _node2.parent = _parent;\n\n          if (_parent.children === undefined) {\n            _parent.children = [_node2];\n          } else {\n            _parent.children.push(_node2);\n          }\n\n          do {\n            _parent.entries += _node2.entries;\n            _parent = _parent.parent;\n          } while (_parent);\n        }\n      }\n    } // Reduce until limit reached\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  while (currentCount > limit) {\n    // Select node that helps reaching the limit most effectively without overmerging\n    var overLimit = currentCount - limit;\n    var bestNode = undefined;\n    var bestCost = Infinity;\n\n    var _iterator3 = _createForOfIteratorHelper(treeMap.values()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n        if (node.entries <= 1 || !node.children || !node.parent) continue;\n        if (node.children.length === 0) continue;\n        if (node.children.length === 1 && !node.value) continue; // Try to select the node with has just a bit more entries than we need to reduce\n        // When just a bit more is over 30% over the limit,\n        // also consider just a bit less entries then we need to reduce\n\n        var cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + limit * 0.3;\n\n        if (cost < bestCost) {\n          bestNode = node;\n          bestCost = cost;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    if (!bestNode) break; // Merge all children\n\n    var reduction = bestNode.entries - 1;\n    bestNode.active = true;\n    bestNode.entries = 1;\n    currentCount -= reduction;\n    var parent = bestNode.parent;\n\n    while (parent) {\n      parent.entries -= reduction;\n      parent = parent.parent;\n    }\n\n    var queue = new Set(bestNode.children);\n\n    var _iterator4 = _createForOfIteratorHelper(queue),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _node = _step4.value;\n        _node.active = false;\n        _node.entries = 0;\n\n        if (_node.children) {\n          var _iterator5 = _createForOfIteratorHelper(_node.children),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var child = _step5.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } // Write down new plan\n\n\n  var newPlan = new Map();\n\n  var _iterator6 = _createForOfIteratorHelper(treeMap.values()),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var rootNode = _step6.value;\n      if (!rootNode.active) continue;\n      var map = new Map();\n\n      var _queue = new Set([rootNode]);\n\n      var _iterator7 = _createForOfIteratorHelper(_queue),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _node3 = _step7.value;\n          if (_node3.active && _node3 !== rootNode) continue;\n\n          if (_node3.value) {\n            if (Array.isArray(_node3.value)) {\n              var _iterator8 = _createForOfIteratorHelper(_node3.value),\n                  _step8;\n\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var item = _step8.value;\n                  map.set(item, _node3.filePath);\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            } else {\n              map.set(_node3.value, _node3.filePath);\n            }\n          }\n\n          if (_node3.children) {\n            var _iterator9 = _createForOfIteratorHelper(_node3.children),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _child = _step9.value;\n\n                _queue.add(_child);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      newPlan.set(rootNode.filePath, map);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return newPlan;\n};","map":{"version":3,"names":["path","require","module","exports","plan","limit","treeMap","Map","filePath","value","set","parent","undefined","children","entries","active","currentCount","size","values","node","parentPath","dirname","get","push","overLimit","bestNode","bestCost","Infinity","length","cost","reduction","queue","Set","child","add","newPlan","rootNode","map","Array","isArray","item"],"sources":["D:/Work/Project/LMS/lms/node_modules/watchpack/lib/reducePlan.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\nmodule.exports = (plan, limit) => {\n\tconst treeMap = new Map();\n\t// Convert to tree\n\tfor (const [filePath, value] of plan) {\n\t\ttreeMap.set(filePath, {\n\t\t\tfilePath,\n\t\t\tparent: undefined,\n\t\t\tchildren: undefined,\n\t\t\tentries: 1,\n\t\t\tactive: true,\n\t\t\tvalue\n\t\t});\n\t}\n\tlet currentCount = treeMap.size;\n\t// Create parents and calculate sum of entries\n\tfor (const node of treeMap.values()) {\n\t\tconst parentPath = path.dirname(node.filePath);\n\t\tif (parentPath !== node.filePath) {\n\t\t\tlet parent = treeMap.get(parentPath);\n\t\t\tif (parent === undefined) {\n\t\t\t\tparent = {\n\t\t\t\t\tfilePath: parentPath,\n\t\t\t\t\tparent: undefined,\n\t\t\t\t\tchildren: [node],\n\t\t\t\t\tentries: node.entries,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t\ttreeMap.set(parentPath, parent);\n\t\t\t\tnode.parent = parent;\n\t\t\t} else {\n\t\t\t\tnode.parent = parent;\n\t\t\t\tif (parent.children === undefined) {\n\t\t\t\t\tparent.children = [node];\n\t\t\t\t} else {\n\t\t\t\t\tparent.children.push(node);\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tparent.entries += node.entries;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t} while (parent);\n\t\t\t}\n\t\t}\n\t}\n\t// Reduce until limit reached\n\twhile (currentCount > limit) {\n\t\t// Select node that helps reaching the limit most effectively without overmerging\n\t\tconst overLimit = currentCount - limit;\n\t\tlet bestNode = undefined;\n\t\tlet bestCost = Infinity;\n\t\tfor (const node of treeMap.values()) {\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\n\t\t\tif (node.children.length === 0) continue;\n\t\t\tif (node.children.length === 1 && !node.value) continue;\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\n\t\t\t// When just a bit more is over 30% over the limit,\n\t\t\t// also consider just a bit less entries then we need to reduce\n\t\t\tconst cost =\n\t\t\t\tnode.entries - 1 >= overLimit\n\t\t\t\t\t? node.entries - 1 - overLimit\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\n\t\t\tif (cost < bestCost) {\n\t\t\t\tbestNode = node;\n\t\t\t\tbestCost = cost;\n\t\t\t}\n\t\t}\n\t\tif (!bestNode) break;\n\t\t// Merge all children\n\t\tconst reduction = bestNode.entries - 1;\n\t\tbestNode.active = true;\n\t\tbestNode.entries = 1;\n\t\tcurrentCount -= reduction;\n\t\tlet parent = bestNode.parent;\n\t\twhile (parent) {\n\t\t\tparent.entries -= reduction;\n\t\t\tparent = parent.parent;\n\t\t}\n\t\tconst queue = new Set(bestNode.children);\n\t\tfor (const node of queue) {\n\t\t\tnode.active = false;\n\t\t\tnode.entries = 0;\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) queue.add(child);\n\t\t\t}\n\t\t}\n\t}\n\t// Write down new plan\n\tconst newPlan = new Map();\n\tfor (const rootNode of treeMap.values()) {\n\t\tif (!rootNode.active) continue;\n\t\tconst map = new Map();\n\t\tconst queue = new Set([rootNode]);\n\t\tfor (const node of queue) {\n\t\t\tif (node.active && node !== rootNode) continue;\n\t\t\tif (node.value) {\n\t\t\t\tif (Array.isArray(node.value)) {\n\t\t\t\t\tfor (const item of node.value) {\n\t\t\t\t\t\tmap.set(item, node.filePath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(node.value, node.filePath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewPlan.set(rootNode.filePath, map);\n\t}\n\treturn newPlan;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAACC,IAAD,EAAOC,KAAP,EAAiB;EACjC,IAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB,CADiC,CAEjC;;EAFiC,2CAGDH,IAHC;EAAA;;EAAA;IAGjC,oDAAsC;MAAA;MAAA,IAA1BI,QAA0B;MAAA,IAAhBC,KAAgB;;MACrCH,OAAO,CAACI,GAAR,CAAYF,QAAZ,EAAsB;QACrBA,QAAQ,EAARA,QADqB;QAErBG,MAAM,EAAEC,SAFa;QAGrBC,QAAQ,EAAED,SAHW;QAIrBE,OAAO,EAAE,CAJY;QAKrBC,MAAM,EAAE,IALa;QAMrBN,KAAK,EAALA;MANqB,CAAtB;IAQA;EAZgC;IAAA;EAAA;IAAA;EAAA;;EAajC,IAAIO,YAAY,GAAGV,OAAO,CAACW,IAA3B,CAbiC,CAcjC;;EAdiC,4CAedX,OAAO,CAACY,MAAR,EAfc;EAAA;;EAAA;IAejC,uDAAqC;MAAA,IAA1BC,MAA0B;MACpC,IAAMC,UAAU,GAAGpB,IAAI,CAACqB,OAAL,CAAaF,MAAI,CAACX,QAAlB,CAAnB;;MACA,IAAIY,UAAU,KAAKD,MAAI,CAACX,QAAxB,EAAkC;QACjC,IAAIG,OAAM,GAAGL,OAAO,CAACgB,GAAR,CAAYF,UAAZ,CAAb;;QACA,IAAIT,OAAM,KAAKC,SAAf,EAA0B;UACzBD,OAAM,GAAG;YACRH,QAAQ,EAAEY,UADF;YAERT,MAAM,EAAEC,SAFA;YAGRC,QAAQ,EAAE,CAACM,MAAD,CAHF;YAIRL,OAAO,EAAEK,MAAI,CAACL,OAJN;YAKRC,MAAM,EAAE,KALA;YAMRN,KAAK,EAAEG;UANC,CAAT;UAQAN,OAAO,CAACI,GAAR,CAAYU,UAAZ,EAAwBT,OAAxB;UACAQ,MAAI,CAACR,MAAL,GAAcA,OAAd;QACA,CAXD,MAWO;UACNQ,MAAI,CAACR,MAAL,GAAcA,OAAd;;UACA,IAAIA,OAAM,CAACE,QAAP,KAAoBD,SAAxB,EAAmC;YAClCD,OAAM,CAACE,QAAP,GAAkB,CAACM,MAAD,CAAlB;UACA,CAFD,MAEO;YACNR,OAAM,CAACE,QAAP,CAAgBU,IAAhB,CAAqBJ,MAArB;UACA;;UACD,GAAG;YACFR,OAAM,CAACG,OAAP,IAAkBK,MAAI,CAACL,OAAvB;YACAH,OAAM,GAAGA,OAAM,CAACA,MAAhB;UACA,CAHD,QAGSA,OAHT;QAIA;MACD;IACD,CA3CgC,CA4CjC;;EA5CiC;IAAA;EAAA;IAAA;EAAA;;EA6CjC,OAAOK,YAAY,GAAGX,KAAtB,EAA6B;IAC5B;IACA,IAAMmB,SAAS,GAAGR,YAAY,GAAGX,KAAjC;IACA,IAAIoB,QAAQ,GAAGb,SAAf;IACA,IAAIc,QAAQ,GAAGC,QAAf;;IAJ4B,4CAKTrB,OAAO,CAACY,MAAR,EALS;IAAA;;IAAA;MAK5B,uDAAqC;QAAA,IAA1BC,IAA0B;QACpC,IAAIA,IAAI,CAACL,OAAL,IAAgB,CAAhB,IAAqB,CAACK,IAAI,CAACN,QAA3B,IAAuC,CAACM,IAAI,CAACR,MAAjD,EAAyD;QACzD,IAAIQ,IAAI,CAACN,QAAL,CAAce,MAAd,KAAyB,CAA7B,EAAgC;QAChC,IAAIT,IAAI,CAACN,QAAL,CAAce,MAAd,KAAyB,CAAzB,IAA8B,CAACT,IAAI,CAACV,KAAxC,EAA+C,SAHX,CAIpC;QACA;QACA;;QACA,IAAMoB,IAAI,GACTV,IAAI,CAACL,OAAL,GAAe,CAAf,IAAoBU,SAApB,GACGL,IAAI,CAACL,OAAL,GAAe,CAAf,GAAmBU,SADtB,GAEGA,SAAS,GAAGL,IAAI,CAACL,OAAjB,GAA2B,CAA3B,GAA+BT,KAAK,GAAG,GAH3C;;QAIA,IAAIwB,IAAI,GAAGH,QAAX,EAAqB;UACpBD,QAAQ,GAAGN,IAAX;UACAO,QAAQ,GAAGG,IAAX;QACA;MACD;IApB2B;MAAA;IAAA;MAAA;IAAA;;IAqB5B,IAAI,CAACJ,QAAL,EAAe,MArBa,CAsB5B;;IACA,IAAMK,SAAS,GAAGL,QAAQ,CAACX,OAAT,GAAmB,CAArC;IACAW,QAAQ,CAACV,MAAT,GAAkB,IAAlB;IACAU,QAAQ,CAACX,OAAT,GAAmB,CAAnB;IACAE,YAAY,IAAIc,SAAhB;IACA,IAAInB,MAAM,GAAGc,QAAQ,CAACd,MAAtB;;IACA,OAAOA,MAAP,EAAe;MACdA,MAAM,CAACG,OAAP,IAAkBgB,SAAlB;MACAnB,MAAM,GAAGA,MAAM,CAACA,MAAhB;IACA;;IACD,IAAMoB,KAAK,GAAG,IAAIC,GAAJ,CAAQP,QAAQ,CAACZ,QAAjB,CAAd;;IAhC4B,4CAiCTkB,KAjCS;IAAA;;IAAA;MAiC5B,uDAA0B;QAAA,IAAfZ,KAAe;QACzBA,KAAI,CAACJ,MAAL,GAAc,KAAd;QACAI,KAAI,CAACL,OAAL,GAAe,CAAf;;QACA,IAAIK,KAAI,CAACN,QAAT,EAAmB;UAAA,4CACEM,KAAI,CAACN,QADP;UAAA;;UAAA;YAClB;cAAA,IAAWoB,KAAX;cAAmCF,KAAK,CAACG,GAAN,CAAUD,KAAV;YAAnC;UADkB;YAAA;UAAA;YAAA;UAAA;QAElB;MACD;IAvC2B;MAAA;IAAA;MAAA;IAAA;EAwC5B,CArFgC,CAsFjC;;;EACA,IAAME,OAAO,GAAG,IAAI5B,GAAJ,EAAhB;;EAvFiC,4CAwFVD,OAAO,CAACY,MAAR,EAxFU;EAAA;;EAAA;IAwFjC,uDAAyC;MAAA,IAA9BkB,QAA8B;MACxC,IAAI,CAACA,QAAQ,CAACrB,MAAd,EAAsB;MACtB,IAAMsB,GAAG,GAAG,IAAI9B,GAAJ,EAAZ;;MACA,IAAMwB,MAAK,GAAG,IAAIC,GAAJ,CAAQ,CAACI,QAAD,CAAR,CAAd;;MAHwC,4CAIrBL,MAJqB;MAAA;;MAAA;QAIxC,uDAA0B;UAAA,IAAfZ,MAAe;UACzB,IAAIA,MAAI,CAACJ,MAAL,IAAeI,MAAI,KAAKiB,QAA5B,EAAsC;;UACtC,IAAIjB,MAAI,CAACV,KAAT,EAAgB;YACf,IAAI6B,KAAK,CAACC,OAAN,CAAcpB,MAAI,CAACV,KAAnB,CAAJ,EAA+B;cAAA,4CACXU,MAAI,CAACV,KADM;cAAA;;cAAA;gBAC9B,uDAA+B;kBAAA,IAApB+B,IAAoB;kBAC9BH,GAAG,CAAC3B,GAAJ,CAAQ8B,IAAR,EAAcrB,MAAI,CAACX,QAAnB;gBACA;cAH6B;gBAAA;cAAA;gBAAA;cAAA;YAI9B,CAJD,MAIO;cACN6B,GAAG,CAAC3B,GAAJ,CAAQS,MAAI,CAACV,KAAb,EAAoBU,MAAI,CAACX,QAAzB;YACA;UACD;;UACD,IAAIW,MAAI,CAACN,QAAT,EAAmB;YAAA,4CACEM,MAAI,CAACN,QADP;YAAA;;YAAA;cAClB,uDAAmC;gBAAA,IAAxBoB,MAAwB;;gBAClCF,MAAK,CAACG,GAAN,CAAUD,MAAV;cACA;YAHiB;cAAA;YAAA;cAAA;YAAA;UAIlB;QACD;MApBuC;QAAA;MAAA;QAAA;MAAA;;MAqBxCE,OAAO,CAACzB,GAAR,CAAY0B,QAAQ,CAAC5B,QAArB,EAA+B6B,GAA/B;IACA;EA9GgC;IAAA;EAAA;IAAA;EAAA;;EA+GjC,OAAOF,OAAP;AACA,CAhHD"},"metadata":{},"sourceType":"script"}