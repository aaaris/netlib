{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _get = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/get.js\")[\"default\"];\n\nvar _getPrototypeOf = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/getPrototypeOf.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/es.weak-map.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar leftCurlyBrace = \"{\".charCodeAt(0);\nvar space = \" \".charCodeAt(0);\nvar keyword = \"assert\";\nvar FUNC_STATEMENT = 1,\n    FUNC_HANGING_STATEMENT = 2,\n    FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  var acorn = Parser.acorn || _acorn;\n  var tt = acorn.tokTypes,\n      TokenType = acorn.TokenType;\n  return /*#__PURE__*/function (_Parser) {\n    _inherits(_class, _Parser);\n\n    var _super = _createSuper(_class);\n\n    function _class() {\n      var _this;\n\n      _classCallCheck(this, _class);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.assertToken = new TokenType(keyword);\n      return _this;\n    }\n\n    _createClass(_class, [{\n      key: \"_codeAt\",\n      value: function _codeAt(i) {\n        return this.input.charCodeAt(i);\n      }\n    }, {\n      key: \"_eat\",\n      value: function _eat(t) {\n        if (this.type !== t) {\n          this.unexpected();\n        }\n\n        this.next();\n      }\n    }, {\n      key: \"readToken\",\n      value: function readToken(code) {\n        var i = 0;\n\n        for (; i < keyword.length; i++) {\n          if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n            return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n          }\n        } // ensure that the keyword is at the correct location\n        // ie `assert{...` or `assert {...`\n\n\n        for (;; i++) {\n          if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n            // Found '{'\n            break;\n          } else if (this._codeAt(this.pos + i) === space) {\n            // white space is allowed between `assert` and `{`, so continue.\n            continue;\n          } else {\n            return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n          }\n        } // If we're inside a dynamic import expression we'll parse\n        // the `assert` keyword as a standard object property name\n        // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n        if (this.type.label === \"{\") {\n          return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n        }\n\n        this.pos += keyword.length;\n        return this.finishToken(this.assertToken);\n      }\n    }, {\n      key: \"parseDynamicImport\",\n      value: function parseDynamicImport(node) {\n        this.next(); // skip `(`\n        // Parse node.source.\n\n        node.source = this.parseMaybeAssign();\n\n        if (this.eat(tt.comma)) {\n          var obj = this.parseObj(false);\n          node.arguments = [obj];\n        }\n\n        this._eat(tt.parenR);\n\n        return this.finishNode(node, \"ImportExpression\");\n      } // ported from acorn/src/statement.js pp.parseExport\n\n    }, {\n      key: \"parseExport\",\n      value: function parseExport(node, exports) {\n        this.next(); // export * from '...'\n\n        if (this.eat(tt.star)) {\n          if (this.options.ecmaVersion >= 11) {\n            if (this.eatContextual(\"as\")) {\n              node.exported = this.parseIdent(true);\n              this.checkExport(exports, node.exported.name, this.lastTokStart);\n            } else {\n              node.exported = null;\n            }\n          }\n\n          this.expectContextual(\"from\");\n\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            var assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n\n          this.semicolon();\n          return this.finishNode(node, \"ExportAllDeclaration\");\n        }\n\n        if (this.eat(tt._default)) {\n          // export default ...\n          this.checkExport(exports, \"default\", this.lastTokStart);\n          var isAsync;\n\n          if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n            var fNode = this.startNode();\n            this.next();\n\n            if (isAsync) {\n              this.next();\n            }\n\n            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n          } else if (this.type === tt._class) {\n            var cNode = this.startNode();\n            node.declaration = this.parseClass(cNode, \"nullableID\");\n          } else {\n            node.declaration = this.parseMaybeAssign();\n            this.semicolon();\n          }\n\n          return this.finishNode(node, \"ExportDefaultDeclaration\");\n        } // export var|const|let|function|class ...\n\n\n        if (this.shouldParseExportStatement()) {\n          node.declaration = this.parseStatement(null);\n\n          if (node.declaration.type === \"VariableDeclaration\") {\n            this.checkVariableExport(exports, node.declaration.declarations);\n          } else {\n            this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n          }\n\n          node.specifiers = [];\n          node.source = null;\n        } else {\n          // export { x, y as z } [from '...']\n          node.declaration = null;\n          node.specifiers = this.parseExportSpecifiers(exports);\n\n          if (this.eatContextual(\"from\")) {\n            if (this.type !== tt.string) {\n              this.unexpected();\n            }\n\n            node.source = this.parseExprAtom();\n\n            if (this.type === this.assertToken) {\n              this.next();\n\n              var _assertions = this.parseImportAssertions();\n\n              if (_assertions) {\n                node.assertions = _assertions;\n              }\n            }\n          } else {\n            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n              // check for keywords used as local names\n              var spec = list[i];\n              this.checkUnreserved(spec.local); // check if export is defined\n\n              this.checkLocalExport(spec.local);\n            }\n\n            node.source = null;\n          }\n\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n    }, {\n      key: \"parseImport\",\n      value: function parseImport(node) {\n        this.next(); // import '...'\n\n        if (this.type === tt.string) {\n          node.specifiers = [];\n          node.source = this.parseExprAtom();\n        } else {\n          node.specifiers = this.parseImportSpecifiers();\n          this.expectContextual(\"from\");\n          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n        }\n\n        if (this.type === this.assertToken) {\n          this.next();\n          var assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n    }, {\n      key: \"parseImportAssertions\",\n      value: function parseImportAssertions() {\n        this._eat(tt.braceL);\n\n        var attrs = this.parseAssertEntries();\n\n        this._eat(tt.braceR);\n\n        return attrs;\n      }\n    }, {\n      key: \"parseAssertEntries\",\n      value: function parseAssertEntries() {\n        var attrs = [];\n        var attrNames = new Set();\n\n        do {\n          if (this.type === tt.braceR) {\n            break;\n          }\n\n          var node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n          var assertionKeyNode = void 0;\n\n          if (this.type === tt.string) {\n            assertionKeyNode = this.parseLiteral(this.value);\n          } else {\n            assertionKeyNode = this.parseIdent(true);\n          }\n\n          this.next();\n          node.key = assertionKeyNode; // check if we already have an entry for an attribute\n          // if a duplicate entry is found, throw an error\n          // for now this logic will come into play only when someone declares `type` twice\n\n          if (attrNames.has(node.key.name)) {\n            this.raise(this.pos, \"Duplicated key in assertions\");\n          }\n\n          attrNames.add(node.key.name);\n\n          if (this.type !== tt.string) {\n            this.raise(this.pos, \"Only string is supported as an assertion value\");\n          }\n\n          node.value = this.parseLiteral(this.value);\n          attrs.push(this.finishNode(node, \"ImportAttribute\"));\n        } while (this.eat(tt.comma));\n\n        return attrs;\n      }\n    }]);\n\n    return _class;\n  }(Parser);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","importAssertions","_acorn","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","Parser","acorn","tt","tokTypes","TokenType","args","assertToken","i","input","t","type","unexpected","next","code","length","_codeAt","pos","label","finishToken","node","source","parseMaybeAssign","eat","comma","parseObj","arguments","_eat","parenR","finishNode","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","raise","add","push"],"sources":["D:/Work/Project/LMS/lms/node_modules/acorn-import-assertions/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}