{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nvar _objectSpread = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/objectSpread2.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Partial<ResolveRequest>} requestOptions request options\n   * @param {string | ResolveStepHook} target target\n   */\n  function ParsePlugin(source, requestOptions, target) {\n    _classCallCheck(this, ParsePlugin);\n\n    this.source = source;\n    this.requestOptions = requestOptions;\n    this.target = target;\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  _createClass(ParsePlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n\n      var target = resolver.ensureHook(this.target);\n      resolver.getHook(this.source).tapAsync(\"ParsePlugin\", function (request, resolveContext, callback) {\n        var parsed = resolver.parse(\n        /** @type {string} */\n        request.request);\n\n        var obj = _objectSpread(_objectSpread(_objectSpread({}, request), parsed), _this.requestOptions);\n\n        if (request.query && !parsed.query) {\n          obj.query = request.query;\n        }\n\n        if (request.fragment && !parsed.fragment) {\n          obj.fragment = request.fragment;\n        }\n\n        if (parsed && resolveContext.log) {\n          if (parsed.module) resolveContext.log(\"Parsed request is a module\");\n          if (parsed.directory) resolveContext.log(\"Parsed request is a directory\");\n        } // There is an edge-case where a request with # can be a path or a fragment -> try both\n\n\n        if (obj.request && !obj.query && obj.fragment) {\n          var directory = obj.fragment.endsWith(\"/\");\n\n          var alternative = _objectSpread(_objectSpread({}, obj), {}, {\n            directory: directory,\n            request: obj.request + (obj.directory ? \"/\" : \"\") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),\n            fragment: \"\"\n          });\n\n          resolver.doResolve(target, alternative, null, resolveContext, function (err, result) {\n            if (err) return callback(err);\n            if (result) return callback(null, result);\n            resolver.doResolve(target, obj, null, resolveContext, callback);\n          });\n          return;\n        }\n\n        resolver.doResolve(target, obj, null, resolveContext, callback);\n      });\n    }\n  }]);\n\n  return ParsePlugin;\n}();","map":{"version":3,"names":["module","exports","source","requestOptions","target","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","parsed","parse","obj","query","fragment","log","directory","endsWith","alternative","slice","doResolve","err","result"],"sources":["D:/Work/Project/LMS/lms/node_modules/enhanced-resolve/lib/ParsePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nmodule.exports = class ParsePlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Partial<ResolveRequest>} requestOptions request options\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, requestOptions, target) {\n\t\tthis.source = source;\n\t\tthis.requestOptions = requestOptions;\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ParsePlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst parsed = resolver.parse(/** @type {string} */ (request.request));\n\t\t\t\tconst obj = { ...request, ...parsed, ...this.requestOptions };\n\t\t\t\tif (request.query && !parsed.query) {\n\t\t\t\t\tobj.query = request.query;\n\t\t\t\t}\n\t\t\t\tif (request.fragment && !parsed.fragment) {\n\t\t\t\t\tobj.fragment = request.fragment;\n\t\t\t\t}\n\t\t\t\tif (parsed && resolveContext.log) {\n\t\t\t\t\tif (parsed.module) resolveContext.log(\"Parsed request is a module\");\n\t\t\t\t\tif (parsed.directory)\n\t\t\t\t\t\tresolveContext.log(\"Parsed request is a directory\");\n\t\t\t\t}\n\t\t\t\t// There is an edge-case where a request with # can be a path or a fragment -> try both\n\t\t\t\tif (obj.request && !obj.query && obj.fragment) {\n\t\t\t\t\tconst directory = obj.fragment.endsWith(\"/\");\n\t\t\t\t\tconst alternative = {\n\t\t\t\t\t\t...obj,\n\t\t\t\t\t\tdirectory,\n\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\tobj.request +\n\t\t\t\t\t\t\t(obj.directory ? \"/\" : \"\") +\n\t\t\t\t\t\t\t(directory ? obj.fragment.slice(0, -1) : obj.fragment),\n\t\t\t\t\t\tfragment: \"\"\n\t\t\t\t\t};\n\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\talternative,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AACA;;;;;;;;;;;;AAEAA,MAAM,CAACC,OAAP;EACC;AACD;AACA;AACA;AACA;EACC,qBAAYC,MAAZ,EAAoBC,cAApB,EAAoCC,MAApC,EAA4C;IAAA;;IAC3C,KAAKF,MAAL,GAAcA,MAAd;IACA,KAAKC,cAAL,GAAsBA,cAAtB;IACA,KAAKC,MAAL,GAAcA,MAAd;EACA;EAED;AACD;AACA;AACA;;;EAfA;IAAA;IAAA,OAgBC,eAAMC,QAAN,EAAgB;MAAA;;MACf,IAAMD,MAAM,GAAGC,QAAQ,CAACC,UAAT,CAAoB,KAAKF,MAAzB,CAAf;MACAC,QAAQ,CACNE,OADF,CACU,KAAKL,MADf,EAEEM,QAFF,CAEW,aAFX,EAE0B,UAACC,OAAD,EAAUC,cAAV,EAA0BC,QAA1B,EAAuC;QAC/D,IAAMC,MAAM,GAAGP,QAAQ,CAACQ,KAAT;QAAe;QAAuBJ,OAAO,CAACA,OAA9C,CAAf;;QACA,IAAMK,GAAG,iDAAQL,OAAR,GAAoBG,MAApB,GAA+B,KAAI,CAACT,cAApC,CAAT;;QACA,IAAIM,OAAO,CAACM,KAAR,IAAiB,CAACH,MAAM,CAACG,KAA7B,EAAoC;UACnCD,GAAG,CAACC,KAAJ,GAAYN,OAAO,CAACM,KAApB;QACA;;QACD,IAAIN,OAAO,CAACO,QAAR,IAAoB,CAACJ,MAAM,CAACI,QAAhC,EAA0C;UACzCF,GAAG,CAACE,QAAJ,GAAeP,OAAO,CAACO,QAAvB;QACA;;QACD,IAAIJ,MAAM,IAAIF,cAAc,CAACO,GAA7B,EAAkC;UACjC,IAAIL,MAAM,CAACZ,MAAX,EAAmBU,cAAc,CAACO,GAAf,CAAmB,4BAAnB;UACnB,IAAIL,MAAM,CAACM,SAAX,EACCR,cAAc,CAACO,GAAf,CAAmB,+BAAnB;QACD,CAb8D,CAc/D;;;QACA,IAAIH,GAAG,CAACL,OAAJ,IAAe,CAACK,GAAG,CAACC,KAApB,IAA6BD,GAAG,CAACE,QAArC,EAA+C;UAC9C,IAAME,SAAS,GAAGJ,GAAG,CAACE,QAAJ,CAAaG,QAAb,CAAsB,GAAtB,CAAlB;;UACA,IAAMC,WAAW,mCACbN,GADa;YAEhBI,SAAS,EAATA,SAFgB;YAGhBT,OAAO,EACNK,GAAG,CAACL,OAAJ,IACCK,GAAG,CAACI,SAAJ,GAAgB,GAAhB,GAAsB,EADvB,KAECA,SAAS,GAAGJ,GAAG,CAACE,QAAJ,CAAaK,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAH,GAA+BP,GAAG,CAACE,QAF7C,CAJe;YAOhBA,QAAQ,EAAE;UAPM,EAAjB;;UASAX,QAAQ,CAACiB,SAAT,CACClB,MADD,EAECgB,WAFD,EAGC,IAHD,EAICV,cAJD,EAKC,UAACa,GAAD,EAAMC,MAAN,EAAiB;YAChB,IAAID,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;YACT,IAAIC,MAAJ,EAAY,OAAOb,QAAQ,CAAC,IAAD,EAAOa,MAAP,CAAf;YACZnB,QAAQ,CAACiB,SAAT,CAAmBlB,MAAnB,EAA2BU,GAA3B,EAAgC,IAAhC,EAAsCJ,cAAtC,EAAsDC,QAAtD;UACA,CATF;UAWA;QACA;;QACDN,QAAQ,CAACiB,SAAT,CAAmBlB,MAAnB,EAA2BU,GAA3B,EAAgC,IAAhC,EAAsCJ,cAAtC,EAAsDC,QAAtD;MACA,CA1CF;IA2CA;EA7DF;;EAAA;AAAA"},"metadata":{},"sourceType":"script"}