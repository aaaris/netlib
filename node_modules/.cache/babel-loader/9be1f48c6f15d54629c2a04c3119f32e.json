{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.string.substr.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nvar _require = require(\"tapable\"),\n    AsyncSeriesBailHook = _require.AsyncSeriesBailHook,\n    AsyncSeriesHook = _require.AsyncSeriesHook,\n    SyncHook = _require.SyncHook;\n\nvar createInnerContext = require(\"./createInnerContext\");\n\nvar _require2 = require(\"./util/identifier\"),\n    parseIdentifier = _require2.parseIdentifier;\n\nvar _require3 = require(\"./util/path\"),\n    _normalize = _require3.normalize,\n    _join = _require3.cachedJoin,\n    getType = _require3.getType,\n    PathType = _require3.PathType;\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/**\n * @typedef {Object} FileSystemStats\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} FileSystemDirent\n * @property {Buffer | string} name\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} PossibleFileSystemError\n * @property {string=} code\n * @property {number=} errno\n * @property {string=} path\n * @property {string=} syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null | undefined} err\n * @param {T=} result\n */\n\n/**\n * @typedef {Object} FileSystem\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readFile\n * @property {(function(string, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void) & function(string, object, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void} readdir\n * @property {((function(string, FileSystemCallback<object>): void) & function(string, object, FileSystemCallback<object>): void)=} readJson\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readlink\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void=} lstat\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} stat\n */\n\n/**\n * @typedef {Object} SyncFileSystem\n * @property {function(string, object=): Buffer | string} readFileSync\n * @property {function(string, object=): (Buffer | string)[] | FileSystemDirent[]} readdirSync\n * @property {(function(string, object=): object)=} readJsonSync\n * @property {function(string, object=): Buffer | string} readlinkSync\n * @property {function(string, object=): FileSystemStats=} lstatSync\n * @property {function(string, object=): FileSystemStats} statSync\n */\n\n/**\n * @typedef {Object} ParsedIdentifier\n * @property {string} request\n * @property {string} query\n * @property {string} fragment\n * @property {boolean} directory\n * @property {boolean} module\n * @property {boolean} file\n * @property {boolean} internal\n */\n\n/**\n * @typedef {Object} BaseResolveRequest\n * @property {string | false} path\n * @property {string=} descriptionFilePath\n * @property {string=} descriptionFileRoot\n * @property {object=} descriptionFileData\n * @property {string=} relativePath\n * @property {boolean=} ignoreSymlinks\n * @property {boolean=} fullySpecified\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/** @template T @typedef {{ add: (T) => void }} WriteOnlySet */\n\n/**\n * Resolve context\n * @typedef {Object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {(function(string): void)=} log log function\n * @property {(function (ResolveRequest): void)=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, function (str) {\n    return str.substr(1).toUpperCase();\n  });\n}\n\nvar Resolver = /*#__PURE__*/function () {\n  /**\n   * @param {FileSystem} fileSystem a filesystem\n   * @param {ResolveOptions} options options\n   */\n  function Resolver(fileSystem, options) {\n    _classCallCheck(this, Resolver);\n\n    this.fileSystem = fileSystem;\n    this.options = options;\n    this.hooks = {\n      /** @type {SyncHook<[ResolveStepHook, ResolveRequest], void>} */\n      resolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n\n      /** @type {SyncHook<[ResolveRequest, Error]>} */\n      noResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n\n      /** @type {ResolveStepHook} */\n      resolve: new AsyncSeriesBailHook([\"request\", \"resolveContext\"], \"resolve\"),\n\n      /** @type {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} */\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n    };\n  }\n  /**\n   * @param {string | ResolveStepHook} name hook name or hook itself\n   * @returns {ResolveStepHook} the hook\n   */\n\n\n  _createClass(Resolver, [{\n    key: \"ensureHook\",\n    value: function ensureHook(name) {\n      if (typeof name !== \"string\") {\n        return name;\n      }\n\n      name = toCamelCase(name);\n\n      if (/^before/.test(name)) {\n        return (\n          /** @type {ResolveStepHook} */\n          this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n            stage: -10\n          })\n        );\n      }\n\n      if (/^after/.test(name)) {\n        return (\n          /** @type {ResolveStepHook} */\n          this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n            stage: 10\n          })\n        );\n      }\n\n      var hook = this.hooks[name];\n\n      if (!hook) {\n        return this.hooks[name] = new AsyncSeriesBailHook([\"request\", \"resolveContext\"], name);\n      }\n\n      return hook;\n    }\n    /**\n     * @param {string | ResolveStepHook} name hook name or hook itself\n     * @returns {ResolveStepHook} the hook\n     */\n\n  }, {\n    key: \"getHook\",\n    value: function getHook(name) {\n      if (typeof name !== \"string\") {\n        return name;\n      }\n\n      name = toCamelCase(name);\n\n      if (/^before/.test(name)) {\n        return (\n          /** @type {ResolveStepHook} */\n          this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n            stage: -10\n          })\n        );\n      }\n\n      if (/^after/.test(name)) {\n        return (\n          /** @type {ResolveStepHook} */\n          this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n            stage: 10\n          })\n        );\n      }\n\n      var hook = this.hooks[name];\n\n      if (!hook) {\n        throw new Error(\"Hook \".concat(name, \" doesn't exist\"));\n      }\n\n      return hook;\n    }\n    /**\n     * @param {object} context context information object\n     * @param {string} path context path\n     * @param {string} request request string\n     * @returns {string | false} result\n     */\n\n  }, {\n    key: \"resolveSync\",\n    value: function resolveSync(context, path, request) {\n      /** @type {Error | null | undefined} */\n      var err = undefined;\n      /** @type {string | false | undefined} */\n\n      var result = undefined;\n      var sync = false;\n      this.resolve(context, path, request, {}, function (e, r) {\n        err = e;\n        result = r;\n        sync = true;\n      });\n\n      if (!sync) {\n        throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n      }\n\n      if (err) throw err;\n      if (result === undefined) throw new Error(\"No result\");\n      return result;\n    }\n    /**\n     * @param {object} context context information object\n     * @param {string} path context path\n     * @param {string} request request string\n     * @param {ResolveContext} resolveContext resolve context\n     * @param {function(Error | null, (string|false)=, ResolveRequest=): void} callback callback function\n     * @returns {void}\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(context, path, request, resolveContext, callback) {\n      var _this = this;\n\n      if (!context || _typeof(context) !== \"object\") return callback(new Error(\"context argument is not an object\"));\n      if (typeof path !== \"string\") return callback(new Error(\"path argument is not a string\"));\n      if (typeof request !== \"string\") return callback(new Error(\"path argument is not a string\"));\n      if (!resolveContext) return callback(new Error(\"resolveContext argument is not set\"));\n      var obj = {\n        context: context,\n        path: path,\n        request: request\n      };\n      var yield_;\n      var yieldCalled = false;\n      var finishYield;\n\n      if (typeof resolveContext[\"yield\"] === \"function\") {\n        var old = resolveContext[\"yield\"];\n\n        yield_ = function yield_(obj) {\n          old(obj);\n          yieldCalled = true;\n        };\n\n        finishYield = function finishYield(result) {\n          if (result) yield_(result);\n          callback(null);\n        };\n      }\n\n      var message = \"resolve '\".concat(request, \"' in '\").concat(path, \"'\");\n\n      var finishResolved = function finishResolved(result) {\n        return callback(null, result.path === false ? false : \"\".concat(result.path.replace(/#/g, \"\\0#\")).concat(result.query ? result.query.replace(/#/g, \"\\0#\") : \"\").concat(result.fragment || \"\"), result);\n      };\n\n      var finishWithoutResolve = function finishWithoutResolve(log) {\n        /**\n         * @type {Error & {details?: string}}\n         */\n        var error = new Error(\"Can't \" + message);\n        error.details = log.join(\"\\n\");\n\n        _this.hooks.noResolve.call(obj, error);\n\n        return callback(error);\n      };\n\n      if (resolveContext.log) {\n        // We need log anyway to capture it in case of an error\n        var parentLog = resolveContext.log;\n        var _log = [];\n        return this.doResolve(this.hooks.resolve, obj, message, {\n          log: function log(msg) {\n            parentLog(msg);\n\n            _log.push(msg);\n          },\n          \"yield\": yield_,\n          fileDependencies: resolveContext.fileDependencies,\n          contextDependencies: resolveContext.contextDependencies,\n          missingDependencies: resolveContext.missingDependencies,\n          stack: resolveContext.stack\n        }, function (err, result) {\n          if (err) return callback(err);\n          if (yieldCalled || result && yield_) return finishYield(result);\n          if (result) return finishResolved(result);\n          return finishWithoutResolve(_log);\n        });\n      } else {\n        // Try to resolve assuming there is no error\n        // We don't log stuff in this case\n        return this.doResolve(this.hooks.resolve, obj, message, {\n          log: undefined,\n          \"yield\": yield_,\n          fileDependencies: resolveContext.fileDependencies,\n          contextDependencies: resolveContext.contextDependencies,\n          missingDependencies: resolveContext.missingDependencies,\n          stack: resolveContext.stack\n        }, function (err, result) {\n          if (err) return callback(err);\n          if (yieldCalled || result && yield_) return finishYield(result);\n          if (result) return finishResolved(result); // log is missing for the error details\n          // so we redo the resolving for the log info\n          // this is more expensive to the success case\n          // is assumed by default\n\n          var _log2 = [];\n          return _this.doResolve(_this.hooks.resolve, obj, message, {\n            log: function log(msg) {\n              return _log2.push(msg);\n            },\n            \"yield\": yield_,\n            stack: resolveContext.stack\n          }, function (err, result) {\n            if (err) return callback(err); // In a case that there is a race condition and yield will be called\n\n            if (yieldCalled || result && yield_) return finishYield(result);\n            return finishWithoutResolve(_log2);\n          });\n        });\n      }\n    }\n  }, {\n    key: \"doResolve\",\n    value: function doResolve(hook, request, message, resolveContext, callback) {\n      var stackEntry = Resolver.createStackEntry(hook, request);\n      var newStack;\n\n      if (resolveContext.stack) {\n        newStack = new Set(resolveContext.stack);\n\n        if (resolveContext.stack.has(stackEntry)) {\n          /**\n           * Prevent recursion\n           * @type {Error & {recursion?: boolean}}\n           */\n          var recursionError = new Error(\"Recursion in resolving\\nStack:\\n  \" + Array.from(newStack).join(\"\\n  \"));\n          recursionError.recursion = true;\n          if (resolveContext.log) resolveContext.log(\"abort resolving because of recursion\");\n          return callback(recursionError);\n        }\n\n        newStack.add(stackEntry);\n      } else {\n        newStack = new Set([stackEntry]);\n      }\n\n      this.hooks.resolveStep.call(hook, request);\n\n      if (hook.isUsed()) {\n        var innerContext = createInnerContext({\n          log: resolveContext.log,\n          \"yield\": resolveContext[\"yield\"],\n          fileDependencies: resolveContext.fileDependencies,\n          contextDependencies: resolveContext.contextDependencies,\n          missingDependencies: resolveContext.missingDependencies,\n          stack: newStack\n        }, message);\n        return hook.callAsync(request, innerContext, function (err, result) {\n          if (err) return callback(err);\n          if (result) return callback(null, result);\n          callback();\n        });\n      } else {\n        callback();\n      }\n    }\n    /**\n     * @param {string} identifier identifier\n     * @returns {ParsedIdentifier} parsed identifier\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(identifier) {\n      var part = {\n        request: \"\",\n        query: \"\",\n        fragment: \"\",\n        module: false,\n        directory: false,\n        file: false,\n        internal: false\n      };\n      var parsedIdentifier = parseIdentifier(identifier);\n      if (!parsedIdentifier) return part;\n\n      var _parsedIdentifier = _slicedToArray(parsedIdentifier, 3);\n\n      part.request = _parsedIdentifier[0];\n      part.query = _parsedIdentifier[1];\n      part.fragment = _parsedIdentifier[2];\n\n      if (part.request.length > 0) {\n        part.internal = this.isPrivate(identifier);\n        part.module = this.isModule(part.request);\n        part.directory = this.isDirectory(part.request);\n\n        if (part.directory) {\n          part.request = part.request.substr(0, part.request.length - 1);\n        }\n      }\n\n      return part;\n    }\n  }, {\n    key: \"isModule\",\n    value: function isModule(path) {\n      return getType(path) === PathType.Normal;\n    }\n  }, {\n    key: \"isPrivate\",\n    value: function isPrivate(path) {\n      return getType(path) === PathType.Internal;\n    }\n    /**\n     * @param {string} path a path\n     * @returns {boolean} true, if the path is a directory path\n     */\n\n  }, {\n    key: \"isDirectory\",\n    value: function isDirectory(path) {\n      return path.endsWith(\"/\");\n    }\n  }, {\n    key: \"join\",\n    value: function join(path, request) {\n      return _join(path, request);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(path) {\n      return _normalize(path);\n    }\n  }], [{\n    key: \"createStackEntry\",\n    value:\n    /**\n     * @param {ResolveStepHook} hook hook\n     * @param {ResolveRequest} request request\n     * @returns {StackEntry} stack entry\n     */\n    function createStackEntry(hook, request) {\n      return hook.name + \": (\" + request.path + \") \" + (request.request || \"\") + (request.query || \"\") + (request.fragment || \"\") + (request.directory ? \" directory\" : \"\") + (request.module ? \" module\" : \"\");\n    }\n  }]);\n\n  return Resolver;\n}();\n\nmodule.exports = Resolver;","map":{"version":3,"names":["require","AsyncSeriesBailHook","AsyncSeriesHook","SyncHook","createInnerContext","parseIdentifier","normalize","join","cachedJoin","getType","PathType","toCamelCase","str","replace","substr","toUpperCase","Resolver","fileSystem","options","hooks","resolveStep","noResolve","resolve","result","name","test","ensureHook","toLowerCase","withOptions","stage","hook","getHook","Error","context","path","request","err","undefined","sync","e","r","resolveContext","callback","obj","yield_","yieldCalled","finishYield","old","message","finishResolved","query","fragment","finishWithoutResolve","log","error","details","call","parentLog","doResolve","msg","push","fileDependencies","contextDependencies","missingDependencies","stack","stackEntry","createStackEntry","newStack","Set","has","recursionError","Array","from","recursion","add","isUsed","innerContext","callAsync","identifier","part","module","directory","file","internal","parsedIdentifier","length","isPrivate","isModule","isDirectory","Normal","Internal","endsWith","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/enhanced-resolve/lib/Resolver.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require(\"tapable\");\nconst createInnerContext = require(\"./createInnerContext\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst {\n\tnormalize,\n\tcachedJoin: join,\n\tgetType,\n\tPathType\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/**\n * @typedef {Object} FileSystemStats\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} FileSystemDirent\n * @property {Buffer | string} name\n * @property {function(): boolean} isDirectory\n * @property {function(): boolean} isFile\n */\n\n/**\n * @typedef {Object} PossibleFileSystemError\n * @property {string=} code\n * @property {number=} errno\n * @property {string=} path\n * @property {string=} syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null | undefined} err\n * @param {T=} result\n */\n\n/**\n * @typedef {Object} FileSystem\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readFile\n * @property {(function(string, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void) & function(string, object, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void} readdir\n * @property {((function(string, FileSystemCallback<object>): void) & function(string, object, FileSystemCallback<object>): void)=} readJson\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readlink\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void=} lstat\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} stat\n */\n\n/**\n * @typedef {Object} SyncFileSystem\n * @property {function(string, object=): Buffer | string} readFileSync\n * @property {function(string, object=): (Buffer | string)[] | FileSystemDirent[]} readdirSync\n * @property {(function(string, object=): object)=} readJsonSync\n * @property {function(string, object=): Buffer | string} readlinkSync\n * @property {function(string, object=): FileSystemStats=} lstatSync\n * @property {function(string, object=): FileSystemStats} statSync\n */\n\n/**\n * @typedef {Object} ParsedIdentifier\n * @property {string} request\n * @property {string} query\n * @property {string} fragment\n * @property {boolean} directory\n * @property {boolean} module\n * @property {boolean} file\n * @property {boolean} internal\n */\n\n/**\n * @typedef {Object} BaseResolveRequest\n * @property {string | false} path\n * @property {string=} descriptionFilePath\n * @property {string=} descriptionFileRoot\n * @property {object=} descriptionFileData\n * @property {string=} relativePath\n * @property {boolean=} ignoreSymlinks\n * @property {boolean=} fullySpecified\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/** @template T @typedef {{ add: (T) => void }} WriteOnlySet */\n\n/**\n * Resolve context\n * @typedef {Object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {(function(string): void)=} log log function\n * @property {(function (ResolveRequest): void)=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\nfunction toCamelCase(str) {\n\treturn str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\n}\n\nclass Resolver {\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @returns {StackEntry} stack entry\n\t */\n\tstatic createStackEntry(hook, request) {\n\t\treturn (\n\t\t\thook.name +\n\t\t\t\": (\" +\n\t\t\trequest.path +\n\t\t\t\") \" +\n\t\t\t(request.request || \"\") +\n\t\t\t(request.query || \"\") +\n\t\t\t(request.fragment || \"\") +\n\t\t\t(request.directory ? \" directory\" : \"\") +\n\t\t\t(request.module ? \" module\" : \"\")\n\t\t);\n\t}\n\n\t/**\n\t * @param {FileSystem} fileSystem a filesystem\n\t * @param {ResolveOptions} options options\n\t */\n\tconstructor(fileSystem, options) {\n\t\tthis.fileSystem = fileSystem;\n\t\tthis.options = options;\n\t\tthis.hooks = {\n\t\t\t/** @type {SyncHook<[ResolveStepHook, ResolveRequest], void>} */\n\t\t\tresolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n\t\t\t/** @type {SyncHook<[ResolveRequest, Error]>} */\n\t\t\tnoResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n\t\t\t/** @type {ResolveStepHook} */\n\t\t\tresolve: new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\t\"resolve\"\n\t\t\t),\n\t\t\t/** @type {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} */\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tensureHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (this.ensureHook(\n\t\t\t\tname[6].toLowerCase() + name.substr(7)\n\t\t\t).withOptions({\n\t\t\t\tstage: -10\n\t\t\t}));\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (this.ensureHook(\n\t\t\t\tname[5].toLowerCase() + name.substr(6)\n\t\t\t).withOptions({\n\t\t\t\tstage: 10\n\t\t\t}));\n\t\t}\n\t\tconst hook = this.hooks[name];\n\t\tif (!hook) {\n\t\t\treturn (this.hooks[name] = new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\tname\n\t\t\t));\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tgetHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (this.getHook(\n\t\t\t\tname[6].toLowerCase() + name.substr(7)\n\t\t\t).withOptions({\n\t\t\t\tstage: -10\n\t\t\t}));\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (this.getHook(\n\t\t\t\tname[5].toLowerCase() + name.substr(6)\n\t\t\t).withOptions({\n\t\t\t\tstage: 10\n\t\t\t}));\n\t\t}\n\t\tconst hook = this.hooks[name];\n\t\tif (!hook) {\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @returns {string | false} result\n\t */\n\tresolveSync(context, path, request) {\n\t\t/** @type {Error | null | undefined} */\n\t\tlet err = undefined;\n\t\t/** @type {string | false | undefined} */\n\t\tlet result = undefined;\n\t\tlet sync = false;\n\t\tthis.resolve(context, path, request, {}, (e, r) => {\n\t\t\terr = e;\n\t\t\tresult = r;\n\t\t\tsync = true;\n\t\t});\n\t\tif (!sync) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\"\n\t\t\t);\n\t\t}\n\t\tif (err) throw err;\n\t\tif (result === undefined) throw new Error(\"No result\");\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @param {ResolveContext} resolveContext resolve context\n\t * @param {function(Error | null, (string|false)=, ResolveRequest=): void} callback callback function\n\t * @returns {void}\n\t */\n\tresolve(context, path, request, resolveContext, callback) {\n\t\tif (!context || typeof context !== \"object\")\n\t\t\treturn callback(new Error(\"context argument is not an object\"));\n\t\tif (typeof path !== \"string\")\n\t\t\treturn callback(new Error(\"path argument is not a string\"));\n\t\tif (typeof request !== \"string\")\n\t\t\treturn callback(new Error(\"path argument is not a string\"));\n\t\tif (!resolveContext)\n\t\t\treturn callback(new Error(\"resolveContext argument is not set\"));\n\n\t\tconst obj = {\n\t\t\tcontext: context,\n\t\t\tpath: path,\n\t\t\trequest: request\n\t\t};\n\n\t\tlet yield_;\n\t\tlet yieldCalled = false;\n\t\tlet finishYield;\n\t\tif (typeof resolveContext.yield === \"function\") {\n\t\t\tconst old = resolveContext.yield;\n\t\t\tyield_ = obj => {\n\t\t\t\told(obj);\n\t\t\t\tyieldCalled = true;\n\t\t\t};\n\t\t\tfinishYield = result => {\n\t\t\t\tif (result) yield_(result);\n\t\t\t\tcallback(null);\n\t\t\t};\n\t\t}\n\n\t\tconst message = `resolve '${request}' in '${path}'`;\n\n\t\tconst finishResolved = result => {\n\t\t\treturn callback(\n\t\t\t\tnull,\n\t\t\t\tresult.path === false\n\t\t\t\t\t? false\n\t\t\t\t\t: `${result.path.replace(/#/g, \"\\0#\")}${\n\t\t\t\t\t\t\tresult.query ? result.query.replace(/#/g, \"\\0#\") : \"\"\n\t\t\t\t\t  }${result.fragment || \"\"}`,\n\t\t\t\tresult\n\t\t\t);\n\t\t};\n\n\t\tconst finishWithoutResolve = log => {\n\t\t\t/**\n\t\t\t * @type {Error & {details?: string}}\n\t\t\t */\n\t\t\tconst error = new Error(\"Can't \" + message);\n\t\t\terror.details = log.join(\"\\n\");\n\t\t\tthis.hooks.noResolve.call(obj, error);\n\t\t\treturn callback(error);\n\t\t};\n\n\t\tif (resolveContext.log) {\n\t\t\t// We need log anyway to capture it in case of an error\n\t\t\tconst parentLog = resolveContext.log;\n\t\t\tconst log = [];\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: msg => {\n\t\t\t\t\t\tparentLog(msg);\n\t\t\t\t\t\tlog.push(msg);\n\t\t\t\t\t},\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) return finishYield(result);\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\t// Try to resolve assuming there is no error\n\t\t\t// We don't log stuff in this case\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: undefined,\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) return finishYield(result);\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\t// log is missing for the error details\n\t\t\t\t\t// so we redo the resolving for the log info\n\t\t\t\t\t// this is more expensive to the success case\n\t\t\t\t\t// is assumed by default\n\n\t\t\t\t\tconst log = [];\n\n\t\t\t\t\treturn this.doResolve(\n\t\t\t\t\t\tthis.hooks.resolve,\n\t\t\t\t\t\tobj,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog: msg => log.push(msg),\n\t\t\t\t\t\t\tyield: yield_,\n\t\t\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t// In a case that there is a race condition and yield will be called\n\t\t\t\t\t\t\tif (yieldCalled || (result && yield_)) return finishYield(result);\n\n\t\t\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tdoResolve(hook, request, message, resolveContext, callback) {\n\t\tconst stackEntry = Resolver.createStackEntry(hook, request);\n\n\t\tlet newStack;\n\t\tif (resolveContext.stack) {\n\t\t\tnewStack = new Set(resolveContext.stack);\n\t\t\tif (resolveContext.stack.has(stackEntry)) {\n\t\t\t\t/**\n\t\t\t\t * Prevent recursion\n\t\t\t\t * @type {Error & {recursion?: boolean}}\n\t\t\t\t */\n\t\t\t\tconst recursionError = new Error(\n\t\t\t\t\t\"Recursion in resolving\\nStack:\\n  \" +\n\t\t\t\t\t\tArray.from(newStack).join(\"\\n  \")\n\t\t\t\t);\n\t\t\t\trecursionError.recursion = true;\n\t\t\t\tif (resolveContext.log)\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\n\t\t\t\treturn callback(recursionError);\n\t\t\t}\n\t\t\tnewStack.add(stackEntry);\n\t\t} else {\n\t\t\tnewStack = new Set([stackEntry]);\n\t\t}\n\t\tthis.hooks.resolveStep.call(hook, request);\n\n\t\tif (hook.isUsed()) {\n\t\t\tconst innerContext = createInnerContext(\n\t\t\t\t{\n\t\t\t\t\tlog: resolveContext.log,\n\t\t\t\t\tyield: resolveContext.yield,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: newStack\n\t\t\t\t},\n\t\t\t\tmessage\n\t\t\t);\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) return callback(null, result);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t * @returns {ParsedIdentifier} parsed identifier\n\t */\n\tparse(identifier) {\n\t\tconst part = {\n\t\t\trequest: \"\",\n\t\t\tquery: \"\",\n\t\t\tfragment: \"\",\n\t\t\tmodule: false,\n\t\t\tdirectory: false,\n\t\t\tfile: false,\n\t\t\tinternal: false\n\t\t};\n\n\t\tconst parsedIdentifier = parseIdentifier(identifier);\n\n\t\tif (!parsedIdentifier) return part;\n\n\t\t[part.request, part.query, part.fragment] = parsedIdentifier;\n\n\t\tif (part.request.length > 0) {\n\t\t\tpart.internal = this.isPrivate(identifier);\n\t\t\tpart.module = this.isModule(part.request);\n\t\t\tpart.directory = this.isDirectory(part.request);\n\t\t\tif (part.directory) {\n\t\t\t\tpart.request = part.request.substr(0, part.request.length - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn part;\n\t}\n\n\tisModule(path) {\n\t\treturn getType(path) === PathType.Normal;\n\t}\n\n\tisPrivate(path) {\n\t\treturn getType(path) === PathType.Internal;\n\t}\n\n\t/**\n\t * @param {string} path a path\n\t * @returns {boolean} true, if the path is a directory path\n\t */\n\tisDirectory(path) {\n\t\treturn path.endsWith(\"/\");\n\t}\n\n\tjoin(path, request) {\n\t\treturn join(path, request);\n\t}\n\n\tnormalize(path) {\n\t\treturn normalize(path);\n\t}\n}\n\nmodule.exports = Resolver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}