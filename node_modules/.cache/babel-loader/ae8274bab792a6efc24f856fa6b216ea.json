{"ast":null,"code":"\"use strict\";\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.number.is-finite.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nvar Range = /*#__PURE__*/function () {\n  function Range() {\n    _classCallCheck(this, Range);\n\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  _createClass(Range, [{\n    key: \"left\",\n    value: function left(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._left.push([value, exclusive]);\n    }\n    /**\n     * @param {number} value\n     * @param {boolean=} exclusive\n     */\n\n  }, {\n    key: \"right\",\n    value: function right(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._right.push([value, exclusive]);\n    }\n    /**\n     * @param {boolean} logic is not logic applied\n     * @return {string} \"smart\" range string representation\n     */\n\n  }, {\n    key: \"format\",\n    value: function format() {\n      var logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var _Range$getRangeValue = Range.getRangeValue(this._left, logic),\n          _Range$getRangeValue2 = _slicedToArray(_Range$getRangeValue, 2),\n          start = _Range$getRangeValue2[0],\n          leftExclusive = _Range$getRangeValue2[1];\n\n      var _Range$getRangeValue3 = Range.getRangeValue(this._right, !logic),\n          _Range$getRangeValue4 = _slicedToArray(_Range$getRangeValue3, 2),\n          end = _Range$getRangeValue4[0],\n          rightExclusive = _Range$getRangeValue4[1];\n\n      if (!Number.isFinite(start) && !Number.isFinite(end)) {\n        return \"\";\n      }\n\n      var realStart = leftExclusive ? start + 1 : start;\n      var realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n      if (realStart === realEnd) {\n        return \"should be \".concat(logic ? \"\" : \"!\", \"= \").concat(realStart);\n      } // e.g. 4 < x < ∞\n\n\n      if (Number.isFinite(start) && !Number.isFinite(end)) {\n        return Range.formatLeft(start, logic, leftExclusive);\n      } // e.g. ∞ < x < 4\n\n\n      if (!Number.isFinite(start) && Number.isFinite(end)) {\n        return Range.formatRight(end, logic, rightExclusive);\n      }\n\n      return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n    }\n  }], [{\n    key: \"getOperator\",\n    value:\n    /**\n     * @param {\"left\" | \"right\"} side\n     * @param {boolean} exclusive\n     * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n     */\n    function getOperator(side, exclusive) {\n      if (side === \"left\") {\n        return exclusive ? \">\" : \">=\";\n      }\n\n      return exclusive ? \"<\" : \"<=\";\n    }\n    /**\n     * @param {number} value\n     * @param {boolean} logic is not logic applied\n     * @param {boolean} exclusive is range exclusive\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatRight\",\n    value: function formatRight(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatLeft(value, !logic, !exclusive);\n      }\n\n      return \"should be \".concat(Range.getOperator(\"right\", exclusive), \" \").concat(value);\n    }\n    /**\n     * @param {number} value\n     * @param {boolean} logic is not logic applied\n     * @param {boolean} exclusive is range exclusive\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatLeft\",\n    value: function formatLeft(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatRight(value, !logic, !exclusive);\n      }\n\n      return \"should be \".concat(Range.getOperator(\"left\", exclusive), \" \").concat(value);\n    }\n    /**\n     * @param {number} start left side value\n     * @param {number} end right side value\n     * @param {boolean} startExclusive is range exclusive from left side\n     * @param {boolean} endExclusive is range exclusive from right side\n     * @param {boolean} logic is not logic applied\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatRange\",\n    value: function formatRange(start, end, startExclusive, endExclusive, logic) {\n      var result = \"should be\";\n      result += \" \".concat(Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive), \" \").concat(start, \" \");\n      result += logic ? \"and\" : \"or\";\n      result += \" \".concat(Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive), \" \").concat(end);\n      return result;\n    }\n    /**\n     * @param {Array<RangeValue>} values\n     * @param {boolean} logic is not logic applied\n     * @return {RangeValue} computed value and it's exclusive flag\n     */\n\n  }, {\n    key: \"getRangeValue\",\n    value: function getRangeValue(values, logic) {\n      var minMax = logic ? Infinity : -Infinity;\n      var j = -1;\n      var predicate = logic ?\n      /** @type {RangeValueCallback} */\n      function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            value = _ref2[0];\n\n        return value <= minMax;\n      } :\n      /** @type {RangeValueCallback} */\n      function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            value = _ref4[0];\n\n        return value >= minMax;\n      };\n\n      for (var i = 0; i < values.length; i++) {\n        if (predicate(values[i])) {\n          var _values$i = _slicedToArray(values[i], 1);\n\n          minMax = _values$i[0];\n          j = i;\n        }\n      }\n\n      if (j > -1) {\n        return values[j];\n      }\n\n      return [Infinity, true];\n    }\n  }]);\n\n  return Range;\n}();\n\nmodule.exports = Range;","map":{"version":3,"names":["Range","_left","_right","value","exclusive","push","logic","getRangeValue","start","leftExclusive","end","rightExclusive","Number","isFinite","realStart","realEnd","formatLeft","formatRight","formatRange","side","getOperator","startExclusive","endExclusive","result","values","minMax","Infinity","j","predicate","i","length","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/terser-webpack-plugin/node_modules/schema-utils/dist/util/Range.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"],"mappings":"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"},"metadata":{},"sourceType":"script"}