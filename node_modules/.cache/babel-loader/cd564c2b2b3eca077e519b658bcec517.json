{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/objectSpread2.js\")[\"default\"];\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/es.weak-map.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar path = require(\"path\");\n\nvar DescriptionFileUtils = require(\"./DescriptionFileUtils\");\n\nvar forEachBail = require(\"./forEachBail\");\n\nvar _require = require(\"./util/entrypoints\"),\n    processImportsField = _require.processImportsField;\n\nvar _require2 = require(\"./util/identifier\"),\n    parseIdentifier = _require2.parseIdentifier;\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\n\nvar dotCode = \".\".charCodeAt(0);\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} targetFile target file\n   * @param {string | ResolveStepHook} targetPackage target package\n   */\n  function ImportsFieldPlugin(source, conditionNames, fieldNamePath, targetFile, targetPackage) {\n    _classCallCheck(this, ImportsFieldPlugin);\n\n    this.source = source;\n    this.targetFile = targetFile;\n    this.targetPackage = targetPackage;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<any, FieldProcessor>} */\n\n    this.fieldProcessorCache = new WeakMap();\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  _createClass(ImportsFieldPlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n\n      var targetFile = resolver.ensureHook(this.targetFile);\n      var targetPackage = resolver.ensureHook(this.targetPackage);\n      resolver.getHook(this.source).tapAsync(\"ImportsFieldPlugin\", function (request, resolveContext, callback) {\n        // When there is no description file, abort\n        if (!request.descriptionFilePath || request.request === undefined) {\n          return callback();\n        }\n\n        var remainingRequest = request.request + request.query + request.fragment;\n        /** @type {ImportsField|null} */\n\n        var importsField = DescriptionFileUtils.getField(request.descriptionFileData, _this.fieldName);\n        if (!importsField) return callback();\n\n        if (request.directory) {\n          return callback(new Error(\"Resolving to directories is not possible with the imports field (request was \".concat(remainingRequest, \"/)\")));\n        }\n\n        var paths;\n\n        try {\n          // We attach the cache to the description file instead of the importsField value\n          // because we use a WeakMap and the importsField could be a string too.\n          // Description file is always an object when exports field can be accessed.\n          var fieldProcessor = _this.fieldProcessorCache.get(request.descriptionFileData);\n\n          if (fieldProcessor === undefined) {\n            fieldProcessor = processImportsField(importsField);\n\n            _this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);\n          }\n\n          paths = fieldProcessor(remainingRequest, _this.conditionNames);\n        } catch (err) {\n          if (resolveContext.log) {\n            resolveContext.log(\"Imports field in \".concat(request.descriptionFilePath, \" can't be processed: \").concat(err));\n          }\n\n          return callback(err);\n        }\n\n        if (paths.length === 0) {\n          return callback(new Error(\"Package import \".concat(remainingRequest, \" is not imported from package \").concat(request.descriptionFileRoot, \" (see imports field in \").concat(request.descriptionFilePath, \")\")));\n        }\n\n        forEachBail(paths, function (p, callback) {\n          var parsedIdentifier = parseIdentifier(p);\n          if (!parsedIdentifier) return callback();\n\n          var _parsedIdentifier = _slicedToArray(parsedIdentifier, 3),\n              path_ = _parsedIdentifier[0],\n              query = _parsedIdentifier[1],\n              fragment = _parsedIdentifier[2];\n\n          switch (path_.charCodeAt(0)) {\n            // should be relative\n            case dotCode:\n              {\n                var obj = _objectSpread(_objectSpread({}, request), {}, {\n                  request: undefined,\n                  path: path.join(\n                  /** @type {string} */\n                  request.descriptionFileRoot, path_),\n                  relativePath: path_,\n                  query: query,\n                  fragment: fragment\n                });\n\n                resolver.doResolve(targetFile, obj, \"using imports field: \" + p, resolveContext, callback);\n                break;\n              }\n            // package resolving\n\n            default:\n              {\n                var _obj = _objectSpread(_objectSpread({}, request), {}, {\n                  request: path_,\n                  relativePath: path_,\n                  fullySpecified: true,\n                  query: query,\n                  fragment: fragment\n                });\n\n                resolver.doResolve(targetPackage, _obj, \"using imports field: \" + p, resolveContext, callback);\n              }\n          }\n        }, function (err, result) {\n          return callback(err, result || null);\n        });\n      });\n    }\n  }]);\n\n  return ImportsFieldPlugin;\n}();","map":{"version":3,"names":["path","require","DescriptionFileUtils","forEachBail","processImportsField","parseIdentifier","dotCode","charCodeAt","module","exports","source","conditionNames","fieldNamePath","targetFile","targetPackage","fieldName","fieldProcessorCache","WeakMap","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","undefined","remainingRequest","query","fragment","importsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","path_","obj","join","relativePath","doResolve","fullySpecified","result"],"sources":["D:/Work/Project/LMS/lms/node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processImportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\nconst dotCode = \".\".charCodeAt(0);\n\nmodule.exports = class ImportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} targetFile target file\n\t * @param {string | ResolveStepHook} targetPackage target package\n\t */\n\tconstructor(\n\t\tsource,\n\t\tconditionNames,\n\t\tfieldNamePath,\n\t\ttargetFile,\n\t\ttargetPackage\n\t) {\n\t\tthis.source = source;\n\t\tthis.targetFile = targetFile;\n\t\tthis.targetPackage = targetPackage;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<any, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst targetFile = resolver.ensureHook(this.targetFile);\n\t\tconst targetPackage = resolver.ensureHook(this.targetPackage);\n\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath || request.request === undefined) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.request + request.query + request.fragment;\n\t\t\t\t/** @type {ImportsField|null} */\n\t\t\t\tconst importsField = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\tthis.fieldName\n\t\t\t\t);\n\t\t\t\tif (!importsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet paths;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the importsField value\n\t\t\t\t\t// because we use a WeakMap and the importsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\trequest.descriptionFileData\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processImportsField(importsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\t\tfieldProcessor\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t(p, callback) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [path_, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tswitch (path_.charCodeAt(0)) {\n\t\t\t\t\t\t\t// should be relative\n\t\t\t\t\t\t\tcase dotCode: {\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\t\t\tpath: path.join(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\t\t\tpath_\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetFile,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\"using imports field: \" + p,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// package resolving\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: path_,\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tfullySpecified: true,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetPackage,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\"using imports field: \" + p,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => callback(err, result || null)\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMC,oBAAoB,GAAGD,OAAO,CAAC,wBAAD,CAApC;;AACA,IAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B;;AACA,eAAgCA,OAAO,CAAC,oBAAD,CAAvC;AAAA,IAAQG,mBAAR,YAAQA,mBAAR;;AACA,gBAA4BH,OAAO,CAAC,mBAAD,CAAnC;AAAA,IAAQI,eAAR,aAAQA,eAAR;AAEA;;AACA;;AACA;;AACA;;;AAEA,IAAMC,OAAO,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAhB;;AAEAC,MAAM,CAACC,OAAP;EACC;AACD;AACA;AACA;AACA;AACA;AACA;EACC,4BACCC,MADD,EAECC,cAFD,EAGCC,aAHD,EAICC,UAJD,EAKCC,aALD,EAME;IAAA;;IACD,KAAKJ,MAAL,GAAcA,MAAd;IACA,KAAKG,UAAL,GAAkBA,UAAlB;IACA,KAAKC,aAAL,GAAqBA,aAArB;IACA,KAAKH,cAAL,GAAsBA,cAAtB;IACA,KAAKI,SAAL,GAAiBH,aAAjB;IACA;;IACA,KAAKI,mBAAL,GAA2B,IAAIC,OAAJ,EAA3B;EACA;EAED;AACD;AACA;AACA;;;EA3BA;IAAA;IAAA,OA4BC,eAAMC,QAAN,EAAgB;MAAA;;MACf,IAAML,UAAU,GAAGK,QAAQ,CAACC,UAAT,CAAoB,KAAKN,UAAzB,CAAnB;MACA,IAAMC,aAAa,GAAGI,QAAQ,CAACC,UAAT,CAAoB,KAAKL,aAAzB,CAAtB;MAEAI,QAAQ,CACNE,OADF,CACU,KAAKV,MADf,EAEEW,QAFF,CAEW,oBAFX,EAEiC,UAACC,OAAD,EAAUC,cAAV,EAA0BC,QAA1B,EAAuC;QACtE;QACA,IAAI,CAACF,OAAO,CAACG,mBAAT,IAAgCH,OAAO,CAACA,OAAR,KAAoBI,SAAxD,EAAmE;UAClE,OAAOF,QAAQ,EAAf;QACA;;QAED,IAAMG,gBAAgB,GACrBL,OAAO,CAACA,OAAR,GAAkBA,OAAO,CAACM,KAA1B,GAAkCN,OAAO,CAACO,QAD3C;QAEA;;QACA,IAAMC,YAAY,GAAG5B,oBAAoB,CAAC6B,QAArB,CACpBT,OAAO,CAACU,mBADY,EAEpB,KAAI,CAACjB,SAFe,CAArB;QAIA,IAAI,CAACe,YAAL,EAAmB,OAAON,QAAQ,EAAf;;QAEnB,IAAIF,OAAO,CAACW,SAAZ,EAAuB;UACtB,OAAOT,QAAQ,CACd,IAAIU,KAAJ,wFACiFP,gBADjF,QADc,CAAf;QAKA;;QAED,IAAIQ,KAAJ;;QAEA,IAAI;UACH;UACA;UACA;UACA,IAAIC,cAAc,GAAG,KAAI,CAACpB,mBAAL,CAAyBqB,GAAzB,CACpBf,OAAO,CAACU,mBADY,CAArB;;UAGA,IAAII,cAAc,KAAKV,SAAvB,EAAkC;YACjCU,cAAc,GAAGhC,mBAAmB,CAAC0B,YAAD,CAApC;;YACA,KAAI,CAACd,mBAAL,CAAyBsB,GAAzB,CACChB,OAAO,CAACU,mBADT,EAECI,cAFD;UAIA;;UACDD,KAAK,GAAGC,cAAc,CAACT,gBAAD,EAAmB,KAAI,CAAChB,cAAxB,CAAtB;QACA,CAfD,CAeE,OAAO4B,GAAP,EAAY;UACb,IAAIhB,cAAc,CAACiB,GAAnB,EAAwB;YACvBjB,cAAc,CAACiB,GAAf,4BACqBlB,OAAO,CAACG,mBAD7B,kCACwEc,GADxE;UAGA;;UACD,OAAOf,QAAQ,CAACe,GAAD,CAAf;QACA;;QAED,IAAIJ,KAAK,CAACM,MAAN,KAAiB,CAArB,EAAwB;UACvB,OAAOjB,QAAQ,CACd,IAAIU,KAAJ,0BACmBP,gBADnB,2CACoEL,OAAO,CAACoB,mBAD5E,oCACyHpB,OAAO,CAACG,mBADjI,OADc,CAAf;QAKA;;QAEDtB,WAAW,CACVgC,KADU,EAEV,UAACQ,CAAD,EAAInB,QAAJ,EAAiB;UAChB,IAAMoB,gBAAgB,GAAGvC,eAAe,CAACsC,CAAD,CAAxC;UAEA,IAAI,CAACC,gBAAL,EAAuB,OAAOpB,QAAQ,EAAf;;UAEvB,uCAAiCoB,gBAAjC;UAAA,IAAOC,KAAP;UAAA,IAAcjB,KAAd;UAAA,IAAqBC,QAArB;;UAEA,QAAQgB,KAAK,CAACtC,UAAN,CAAiB,CAAjB,CAAR;YACC;YACA,KAAKD,OAAL;cAAc;gBACb,IAAMwC,GAAG,mCACLxB,OADK;kBAERA,OAAO,EAAEI,SAFD;kBAGR1B,IAAI,EAAEA,IAAI,CAAC+C,IAAL;kBACL;kBAAuBzB,OAAO,CAACoB,mBAD1B,EAELG,KAFK,CAHE;kBAORG,YAAY,EAAEH,KAPN;kBAQRjB,KAAK,EAALA,KARQ;kBASRC,QAAQ,EAARA;gBATQ,EAAT;;gBAYAX,QAAQ,CAAC+B,SAAT,CACCpC,UADD,EAECiC,GAFD,EAGC,0BAA0BH,CAH3B,EAICpB,cAJD,EAKCC,QALD;gBAOA;cACA;YAED;;YACA;cAAS;gBACR,IAAMsB,IAAG,mCACLxB,OADK;kBAERA,OAAO,EAAEuB,KAFD;kBAGRG,YAAY,EAAEH,KAHN;kBAIRK,cAAc,EAAE,IAJR;kBAKRtB,KAAK,EAALA,KALQ;kBAMRC,QAAQ,EAARA;gBANQ,EAAT;;gBASAX,QAAQ,CAAC+B,SAAT,CACCnC,aADD,EAECgC,IAFD,EAGC,0BAA0BH,CAH3B,EAICpB,cAJD,EAKCC,QALD;cAOA;UA3CF;QA6CA,CAtDS,EAuDV,UAACe,GAAD,EAAMY,MAAN;UAAA,OAAiB3B,QAAQ,CAACe,GAAD,EAAMY,MAAM,IAAI,IAAhB,CAAzB;QAAA,CAvDU,CAAX;MAyDA,CApHF;IAqHA;EArJF;;EAAA;AAAA"},"metadata":{},"sourceType":"script"}