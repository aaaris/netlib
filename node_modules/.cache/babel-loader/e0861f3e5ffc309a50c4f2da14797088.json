{"ast":null,"code":"var _possibleConstructorReturn = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\")[\"default\"];\n\nvar _inherits = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nvar _asyncToGenerator = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/asyncToGenerator.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.index-of.js\");\n\nrequire(\"core-js/modules/es.array-buffer.slice.js\");\n\nrequire(\"core-js/modules/es.typed-array.uint8-array.js\");\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.copy-within.js\");\n\nrequire(\"core-js/modules/es.typed-array.every.js\");\n\nrequire(\"core-js/modules/es.typed-array.fill.js\");\n\nrequire(\"core-js/modules/es.typed-array.filter.js\");\n\nrequire(\"core-js/modules/es.typed-array.find.js\");\n\nrequire(\"core-js/modules/es.typed-array.find-index.js\");\n\nrequire(\"core-js/modules/es.typed-array.for-each.js\");\n\nrequire(\"core-js/modules/es.typed-array.includes.js\");\n\nrequire(\"core-js/modules/es.typed-array.index-of.js\");\n\nrequire(\"core-js/modules/es.typed-array.iterator.js\");\n\nrequire(\"core-js/modules/es.typed-array.join.js\");\n\nrequire(\"core-js/modules/es.typed-array.last-index-of.js\");\n\nrequire(\"core-js/modules/es.typed-array.map.js\");\n\nrequire(\"core-js/modules/es.typed-array.reduce.js\");\n\nrequire(\"core-js/modules/es.typed-array.reduce-right.js\");\n\nrequire(\"core-js/modules/es.typed-array.reverse.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nrequire(\"core-js/modules/es.typed-array.slice.js\");\n\nrequire(\"core-js/modules/es.typed-array.some.js\");\n\nrequire(\"core-js/modules/es.typed-array.sort.js\");\n\nrequire(\"core-js/modules/es.typed-array.subarray.js\");\n\nrequire(\"core-js/modules/es.typed-array.to-locale-string.js\");\n\nrequire(\"core-js/modules/es.typed-array.to-string.js\");\n\nrequire(\"core-js/modules/es.array.at.js\");\n\nrequire(\"core-js/modules/es.string.at-alternative.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.some.js\");\n\nrequire(\"core-js/modules/es.date.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.search.js\");\n\nrequire(\"core-js/modules/es.array.every.js\");\n\nrequire(\"core-js/modules/es.array.for-each.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\n/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nvar util = require(\"./util\");\n\nvar binarySearch = require(\"./binary-search\");\n\nvar ArraySet = require(\"./array-set\").ArraySet;\n\nvar base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\n\n\nvar readWasm = require(\"../lib/read-wasm\");\n\nvar wasm = require(\"./wasm\");\n\nvar INTERNAL = Symbol(\"smcInternal\");\n\nvar SourceMapConsumer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function SourceMapConsumer(aSourceMap, aSourceMapURL) {\n    _classCallCheck(this, SourceMapConsumer);\n\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  _createClass(SourceMapConsumer, [{\n    key: \"eachMapping\",\n    value:\n    /**\n     * Iterate over each mapping between an original source/line/column and a\n     * generated line/column in this source map.\n     *\n     * @param Function aCallback\n     *        The function that is called with each mapping.\n     * @param Object aContext\n     *        Optional. If specified, this object will be the value of `this` every\n     *        time that `aCallback` is called.\n     * @param aOrder\n     *        Either `SourceMapConsumer.GENERATED_ORDER` or\n     *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n     *        iterate over the mappings sorted by the generated file's line/column\n     *        order or the original's source/line/column order, respectively. Defaults to\n     *        `SourceMapConsumer.GENERATED_ORDER`.\n     */\n    function eachMapping(aCallback, aContext, aOrder) {\n      throw new Error(\"Subclasses must implement eachMapping\");\n    }\n    /**\n     * Returns all generated line and column information for the original source,\n     * line, and column provided. If no column is provided, returns all mappings\n     * corresponding to a either the line we are searching for or the next\n     * closest line that has any mappings. Otherwise, returns all mappings\n     * corresponding to the given line and either the column we are searching for\n     * or the next closest column that has any offsets.\n     *\n     * The only argument is an object with the following properties:\n     *\n     *   - source: The filename of the original source.\n     *   - line: The line number in the original source.  The line number is 1-based.\n     *   - column: Optional. the column number in the original source.\n     *    The column number is 0-based.\n     *\n     * and an array of objects is returned, each with the following properties:\n     *\n     *   - line: The line number in the generated source, or null.  The\n     *    line number is 1-based.\n     *   - column: The column number in the generated source, or null.\n     *    The column number is 0-based.\n     */\n\n  }, {\n    key: \"allGeneratedPositionsFor\",\n    value: function allGeneratedPositionsFor(aArgs) {\n      throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      throw new Error(\"Subclasses must implement destroy\");\n    }\n  }], [{\n    key: \"initialize\",\n    value: function initialize(opts) {\n      readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n    }\n  }, {\n    key: \"fromSourceMap\",\n    value: function fromSourceMap(aSourceMap, aSourceMapURL) {\n      return _factoryBSM(aSourceMap, aSourceMapURL);\n    }\n    /**\n     * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n     * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n     * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n     * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n     * value.\n     *\n     * You must not use the consumer after `f` completes!\n     *\n     * By using `with`, you do not have to remember to manually call `destroy` on\n     * the consumer, since it will be called automatically once `f` completes.\n     *\n     * ```js\n     * const xSquared = await SourceMapConsumer.with(\n     *   myRawSourceMap,\n     *   null,\n     *   async function (consumer) {\n     *     // Use `consumer` inside here and don't worry about remembering\n     *     // to call `destroy`.\n     *\n     *     const x = await whatever(consumer);\n     *     return x * x;\n     *   }\n     * );\n     *\n     * // You may not use that `consumer` anymore out here; it has\n     * // been destroyed. But you can use `xSquared`.\n     * console.log(xSquared);\n     * ```\n     */\n\n  }, {\n    key: \"with\",\n    value: function () {\n      var _with2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(rawSourceMap, sourceMapUrl, f) {\n        var consumer;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n\n              case 2:\n                consumer = _context.sent;\n                _context.prev = 3;\n                _context.next = 6;\n                return f(consumer);\n\n              case 6:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 7:\n                _context.prev = 7;\n                consumer.destroy();\n                return _context.finish(7);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3,, 7, 10]]);\n      }));\n\n      function _with(_x, _x2, _x3) {\n        return _with2.apply(this, arguments);\n      }\n\n      return _with;\n    }()\n  }]);\n\n  return SourceMapConsumer;\n}();\n/**\n * The version of the source mapping spec that we are consuming.\n */\n\n\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\n\nvar BasicSourceMapConsumer = /*#__PURE__*/function (_SourceMapConsumer) {\n  \"use strict\";\n\n  _inherits(BasicSourceMapConsumer, _SourceMapConsumer);\n\n  var _super = _createSuper(BasicSourceMapConsumer);\n\n  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var _this;\n\n    _classCallCheck(this, BasicSourceMapConsumer);\n\n    return _possibleConstructorReturn(_this, (_this = _super.call(this, INTERNAL)).then(function (that) {\n      var sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      var version = util.getArg(sourceMap, \"version\");\n      var sources = util.getArg(sourceMap, \"sources\").map(String); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n\n      var names = util.getArg(sourceMap, \"names\", []);\n      var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      var mappings = util.getArg(sourceMap, \"mappings\");\n      var file = util.getArg(sourceMap, \"file\", null); // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map(); // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n      that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function (s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      }), true);\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n      return wasm().then(function (w) {\n        that._wasm = w;\n        return that;\n      });\n    }));\n  }\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n\n\n  _createClass(BasicSourceMapConsumer, [{\n    key: \"_findSourceIndex\",\n    value: function _findSourceIndex(aSource) {\n      // In the most common usecases, we'll be constantly looking up the index for the same source\n      // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n      var cachedIndex = this._sourceLookupCache.get(aSource);\n\n      if (typeof cachedIndex === \"number\") {\n        return cachedIndex;\n      } // Treat the source as map-relative overall by default.\n\n\n      var sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);\n\n      if (this._absoluteSources.has(sourceAsMapRelative)) {\n        var index = this._absoluteSources.indexOf(sourceAsMapRelative);\n\n        this._sourceLookupCache.set(aSource, index);\n\n        return index;\n      } // Fall back to treating the source as sourceRoot-relative.\n\n\n      var sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);\n\n      if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n        var _index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n\n        this._sourceLookupCache.set(aSource, _index);\n\n        return _index;\n      } // To avoid this cache growing forever, we do not cache lookup misses.\n\n\n      return -1;\n    }\n    /**\n     * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n     *\n     * @param SourceMapGenerator aSourceMap\n     *        The source map that will be consumed.\n     * @param String aSourceMapURL\n     *        The URL at which the source map can be found (optional)\n     * @returns BasicSourceMapConsumer\n     */\n\n  }, {\n    key: \"sources\",\n    get: function get() {\n      return this._absoluteSources.toArray();\n    }\n  }, {\n    key: \"_getMappingsPtr\",\n    value: function _getMappingsPtr() {\n      if (this._mappingsPtr === 0) {\n        this._parseMappings();\n      }\n\n      return this._mappingsPtr;\n    }\n    /**\n     * Parse the mappings in a string in to a data structure which we can easily\n     * query (the ordered arrays in the `this.__generatedMappings` and\n     * `this.__originalMappings` properties).\n     */\n\n  }, {\n    key: \"_parseMappings\",\n    value: function _parseMappings() {\n      var aStr = this._mappings;\n      var size = aStr.length;\n\n      var mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n\n      var mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n\n      for (var i = 0; i < size; i++) {\n        mappingsBuf[i] = aStr.charCodeAt(i);\n      }\n\n      var mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n      if (!mappingsPtr) {\n        var error = this._wasm.exports.get_last_error();\n\n        var msg = \"Error parsing mappings (code \".concat(error, \"): \"); // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n\n        switch (error) {\n          case 1:\n            msg += \"the mappings contained a negative line, column, source index, or name index\";\n            break;\n\n          case 2:\n            msg += \"the mappings contained a number larger than 2**32\";\n            break;\n\n          case 3:\n            msg += \"reached EOF while in the middle of parsing a VLQ\";\n            break;\n\n          case 4:\n            msg += \"invalid base 64 character while parsing a VLQ\";\n            break;\n\n          default:\n            msg += \"unknown error code\";\n            break;\n        }\n\n        throw new Error(msg);\n      }\n\n      this._mappingsPtr = mappingsPtr;\n    }\n  }, {\n    key: \"eachMapping\",\n    value: function eachMapping(aCallback, aContext, aOrder) {\n      var _this2 = this;\n\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n      this._wasm.withMappingCallback(function (mapping) {\n        if (mapping.source !== null) {\n          mapping.source = _this2._absoluteSources.at(mapping.source);\n\n          if (mapping.name !== null) {\n            mapping.name = _this2._names.at(mapping.name);\n          }\n        }\n\n        if (_this2._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n          mapping.lastGeneratedColumn = Infinity;\n        }\n\n        aCallback.call(context, mapping);\n      }, function () {\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            _this2._wasm.exports.by_generated_location(_this2._getMappingsPtr());\n\n            break;\n\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            _this2._wasm.exports.by_original_location(_this2._getMappingsPtr());\n\n            break;\n\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n      });\n    }\n  }, {\n    key: \"allGeneratedPositionsFor\",\n    value: function allGeneratedPositionsFor(aArgs) {\n      var _this3 = this;\n\n      var source = util.getArg(aArgs, \"source\");\n      var originalLine = util.getArg(aArgs, \"line\");\n      var originalColumn = aArgs.column || 0;\n      source = this._findSourceIndex(source);\n\n      if (source < 0) {\n        return [];\n      }\n\n      if (originalLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n\n      if (originalColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n\n      var mappings = [];\n\n      this._wasm.withMappingCallback(function (m) {\n        var lastColumn = m.lastGeneratedColumn;\n\n        if (_this3._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn: lastColumn\n        });\n      }, function () {\n        _this3._wasm.exports.all_generated_locations_for(_this3._getMappingsPtr(), source, originalLine - 1, \"column\" in aArgs, originalColumn);\n      });\n\n      return mappings;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._mappingsPtr !== 0) {\n        this._wasm.exports.free_mappings(this._mappingsPtr);\n\n        this._mappingsPtr = 0;\n      }\n    }\n    /**\n     * Compute the last column for each generated mapping. The last column is\n     * inclusive.\n     */\n\n  }, {\n    key: \"computeColumnSpans\",\n    value: function computeColumnSpans() {\n      if (this._computedColumnSpans) {\n        return;\n      }\n\n      this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n\n      this._computedColumnSpans = true;\n    }\n    /**\n     * Returns the original source, line, and column information for the generated\n     * source's line and column positions provided. The only argument is an object\n     * with the following properties:\n     *\n     *   - line: The line number in the generated source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the generated source.  The column\n     *     number is 0-based.\n     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n     *     closest element that is smaller than or greater than the one we are\n     *     searching for, respectively, if the exact element cannot be found.\n     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - source: The original source file, or null.\n     *   - line: The line number in the original source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the original source, or null.  The\n     *     column number is 0-based.\n     *   - name: The original identifier, or null.\n     */\n\n  }, {\n    key: \"originalPositionFor\",\n    value: function originalPositionFor(aArgs) {\n      var _this4 = this;\n\n      var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n      };\n\n      if (needle.generatedLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n\n      if (needle.generatedColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n\n      var bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n      if (bias == null) {\n        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n      }\n\n      var mapping;\n\n      this._wasm.withMappingCallback(function (m) {\n        return mapping = m;\n      }, function () {\n        _this4._wasm.exports.original_location_for(_this4._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);\n      });\n\n      if (mapping) {\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, \"source\", null);\n\n          if (source !== null) {\n            source = this._absoluteSources.at(source);\n          }\n\n          var name = util.getArg(mapping, \"name\", null);\n\n          if (name !== null) {\n            name = this._names.at(name);\n          }\n\n          return {\n            source: source,\n            line: util.getArg(mapping, \"originalLine\", null),\n            column: util.getArg(mapping, \"originalColumn\", null),\n            name: name\n          };\n        }\n      }\n\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n    /**\n     * Return true if we have the source content for every source in the source\n     * map, false otherwise.\n     */\n\n  }, {\n    key: \"hasContentsOfAllSources\",\n    value: function hasContentsOfAllSources() {\n      if (!this.sourcesContent) {\n        return false;\n      }\n\n      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n        return sc == null;\n      });\n    }\n    /**\n     * Returns the original source content. The only argument is the url of the\n     * original source file. Returns null if no original source content is\n     * available.\n     */\n\n  }, {\n    key: \"sourceContentFor\",\n    value: function sourceContentFor(aSource, nullOnMissing) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n\n      var index = this._findSourceIndex(aSource);\n\n      if (index >= 0) {\n        return this.sourcesContent[index];\n      } // This function is used recursively from\n      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n      // don't want to throw if we can't find the source - we just want to\n      // return null, so we provide a flag to exit gracefully.\n\n\n      if (nullOnMissing) {\n        return null;\n      }\n\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n    /**\n     * Returns the generated line and column information for the original source,\n     * line, and column positions provided. The only argument is an object with\n     * the following properties:\n     *\n     *   - source: The filename of the original source.\n     *   - line: The line number in the original source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the original source.  The column\n     *     number is 0-based.\n     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n     *     closest element that is smaller than or greater than the one we are\n     *     searching for, respectively, if the exact element cannot be found.\n     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - line: The line number in the generated source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the generated source, or null.\n     *     The column number is 0-based.\n     */\n\n  }, {\n    key: \"generatedPositionFor\",\n    value: function generatedPositionFor(aArgs) {\n      var _this5 = this;\n\n      var source = util.getArg(aArgs, \"source\");\n      source = this._findSourceIndex(source);\n\n      if (source < 0) {\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      }\n\n      var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, \"line\"),\n        originalColumn: util.getArg(aArgs, \"column\")\n      };\n\n      if (needle.originalLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n\n      if (needle.originalColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n\n      var bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n      if (bias == null) {\n        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n      }\n\n      var mapping;\n\n      this._wasm.withMappingCallback(function (m) {\n        return mapping = m;\n      }, function () {\n        _this5._wasm.exports.generated_location_for(_this5._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);\n      });\n\n      if (mapping) {\n        if (mapping.source === needle.source) {\n          var lastColumn = mapping.lastGeneratedColumn;\n\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n\n          return {\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn: lastColumn\n          };\n        }\n      }\n\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n  }], [{\n    key: \"fromSourceMap\",\n    value: function fromSourceMap(aSourceMap, aSourceMapURL) {\n      return new BasicSourceMapConsumer(aSourceMap.toString());\n    }\n  }]);\n\n  return BasicSourceMapConsumer;\n}(SourceMapConsumer);\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\n\nvar IndexedSourceMapConsumer = /*#__PURE__*/function (_SourceMapConsumer2) {\n  \"use strict\";\n\n  _inherits(IndexedSourceMapConsumer, _SourceMapConsumer2);\n\n  var _super2 = _createSuper(IndexedSourceMapConsumer);\n\n  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var _this6;\n\n    _classCallCheck(this, IndexedSourceMapConsumer);\n\n    return _possibleConstructorReturn(_this6, (_this6 = _super2.call(this, INTERNAL)).then(function (that) {\n      var sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      var version = util.getArg(sourceMap, \"version\");\n      var sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      var lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(function (s) {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n\n        var offset = util.getArg(s, \"offset\");\n        var offsetLine = util.getArg(offset, \"line\");\n        var offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n\n        lastOffset = offset;\n        var cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(function (consumer) {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer: consumer\n          };\n        });\n      })).then(function (s) {\n        that._sections = s;\n        return that;\n      });\n    }));\n  }\n  /**\n   * The list of original sources.\n   */\n\n\n  _createClass(IndexedSourceMapConsumer, [{\n    key: \"sources\",\n    get: function get() {\n      var sources = [];\n\n      for (var i = 0; i < this._sections.length; i++) {\n        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n          sources.push(this._sections[i].consumer.sources[j]);\n        }\n      }\n\n      return sources;\n    }\n    /**\n     * Returns the original source, line, and column information for the generated\n     * source's line and column positions provided. The only argument is an object\n     * with the following properties:\n     *\n     *   - line: The line number in the generated source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the generated source.  The column\n     *     number is 0-based.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - source: The original source file, or null.\n     *   - line: The line number in the original source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the original source, or null.  The\n     *     column number is 0-based.\n     *   - name: The original identifier, or null.\n     */\n\n  }, {\n    key: \"originalPositionFor\",\n    value: function originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n      }; // Find the section containing the generated position we're trying to map\n      // to an original position.\n\n      var sectionIndex = binarySearch.search(needle, this._sections, function (aNeedle, section) {\n        var cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n\n        if (cmp) {\n          return cmp;\n        }\n\n        return aNeedle.generatedColumn - section.generatedOffset.generatedColumn;\n      });\n      var section = this._sections[sectionIndex];\n\n      if (!section) {\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      }\n\n      return section.consumer.originalPositionFor({\n        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n        bias: aArgs.bias\n      });\n    }\n    /**\n     * Return true if we have the source content for every source in the source\n     * map, false otherwise.\n     */\n\n  }, {\n    key: \"hasContentsOfAllSources\",\n    value: function hasContentsOfAllSources() {\n      return this._sections.every(function (s) {\n        return s.consumer.hasContentsOfAllSources();\n      });\n    }\n    /**\n     * Returns the original source content. The only argument is the url of the\n     * original source file. Returns null if no original source content is\n     * available.\n     */\n\n  }, {\n    key: \"sourceContentFor\",\n    value: function sourceContentFor(aSource, nullOnMissing) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n        var content = section.consumer.sourceContentFor(aSource, true);\n\n        if (content) {\n          return content;\n        }\n      }\n\n      if (nullOnMissing) {\n        return null;\n      }\n\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  }, {\n    key: \"_findSectionIndex\",\n    value: function _findSectionIndex(source) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var consumer = this._sections[i].consumer;\n\n        if (consumer._findSourceIndex(source) !== -1) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * Returns the generated line and column information for the original source,\n     * line, and column positions provided. The only argument is an object with\n     * the following properties:\n     *\n     *   - source: The filename of the original source.\n     *   - line: The line number in the original source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the original source.  The column\n     *     number is 0-based.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - line: The line number in the generated source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the generated source, or null.\n     *     The column number is 0-based.\n     */\n\n  }, {\n    key: \"generatedPositionFor\",\n    value: function generatedPositionFor(aArgs) {\n      var index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n\n      var section = index >= 0 ? this._sections[index] : null;\n      var nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;\n      var generatedPosition = section && section.consumer.generatedPositionFor(aArgs);\n\n      if (generatedPosition && generatedPosition.line !== null) {\n        var lineShift = section.generatedOffset.generatedLine - 1;\n        var columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {\n          generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;\n        }\n\n        generatedPosition.line += lineShift;\n        return generatedPosition;\n      }\n\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n  }, {\n    key: \"allGeneratedPositionsFor\",\n    value: function allGeneratedPositionsFor(aArgs) {\n      var index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n\n      var section = index >= 0 ? this._sections[index] : null;\n      var nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;\n      if (!section) return [];\n      return section.consumer.allGeneratedPositionsFor(aArgs).map(function (generatedPosition) {\n        var lineShift = section.generatedOffset.generatedLine - 1;\n        var columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {\n          generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;\n        }\n\n        generatedPosition.line += lineShift;\n        return generatedPosition;\n      });\n    }\n  }, {\n    key: \"eachMapping\",\n    value: function eachMapping(aCallback, aContext, aOrder) {\n      var _this7 = this;\n\n      this._sections.forEach(function (section, index) {\n        var nextSection = index + 1 < _this7._sections.length ? _this7._sections[index + 1] : null;\n        var generatedOffset = section.generatedOffset;\n        var lineShift = generatedOffset.generatedLine - 1;\n        var columnShift = generatedOffset.generatedColumn - 1;\n        section.consumer.eachMapping(function (mapping) {\n          if (mapping.generatedLine === 1) {\n            mapping.generatedColumn += columnShift;\n\n            if (typeof mapping.lastGeneratedColumn === \"number\") {\n              mapping.lastGeneratedColumn += columnShift;\n            }\n          }\n\n          if (mapping.lastGeneratedColumn === Infinity && nextSection && mapping.generatedLine === nextSection.generatedOffset.generatedLine) {\n            mapping.lastGeneratedColumn = nextSection.generatedOffset.generatedColumn - 2;\n          }\n\n          mapping.generatedLine += lineShift;\n          aCallback.call(this, mapping);\n        }, aContext, aOrder);\n      });\n    }\n  }, {\n    key: \"computeColumnSpans\",\n    value: function computeColumnSpans() {\n      for (var i = 0; i < this._sections.length; i++) {\n        this._sections[i].consumer.computeColumnSpans();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i = 0; i < this._sections.length; i++) {\n        this._sections[i].consumer.destroy();\n      }\n    }\n  }]);\n\n  return IndexedSourceMapConsumer;\n}(SourceMapConsumer);\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\n\nfunction _factory(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}","map":{"version":3,"names":["util","require","binarySearch","ArraySet","base64VLQ","readWasm","wasm","INTERNAL","Symbol","SourceMapConsumer","aSourceMap","aSourceMapURL","Promise","resolve","_factory","aCallback","aContext","aOrder","Error","aArgs","opts","initialize","_factoryBSM","rawSourceMap","sourceMapUrl","f","consumer","destroy","prototype","_version","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","exports","BasicSourceMapConsumer","then","that","sourceMap","parseSourceMapInput","version","getArg","sources","map","String","names","sourceRoot","sourcesContent","mappings","file","_sourceLookupCache","Map","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","aSource","cachedIndex","get","sourceAsMapRelative","has","index","indexOf","set","sourceAsSourceRootRelative","_parseMappings","aStr","size","length","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","buffer","i","charCodeAt","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","withMappingCallback","mapping","source","at","name","lastGeneratedColumn","Infinity","call","by_generated_location","_getMappingsPtr","by_original_location","originalLine","originalColumn","column","_findSourceIndex","m","lastColumn","push","line","generatedLine","generatedColumn","all_generated_locations_for","free_mappings","compute_column_spans","needle","bias","original_location_for","some","sc","nullOnMissing","generated_location_for","toString","IndexedSourceMapConsumer","sections","lastOffset","all","url","offset","offsetLine","offsetColumn","cons","generatedOffset","_sections","j","sectionIndex","search","aNeedle","section","cmp","originalPositionFor","every","hasContentsOfAllSources","content","sourceContentFor","_findSectionIndex","nextSection","generatedPosition","generatedPositionFor","lineShift","columnShift","allGeneratedPositionsFor","forEach","eachMapping","computeColumnSpans","fromSourceMap"],"sources":["D:/Work/Project/LMS/lms/node_modules/terser/node_modules/source-map/lib/source-map-consumer.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String);\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map();\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      }), true);\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    }\n\n    // Treat the source as map-relative overall by default.\n    const sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // Fall back to treating the source as sourceRoot-relative.\n    const sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // To avoid this cache growing forever, we do not cache lookup misses.\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._absoluteSources.at(mapping.source);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n        if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n          mapping.lastGeneratedColumn = Infinity;\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const { consumer } = this._sections[i];\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    const generatedPosition =\n      section && section.consumer.generatedPositionFor(aArgs);\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (\n        generatedPosition.lastColumn === Infinity &&\n        nextSection &&\n        generatedPosition.line === nextSection.generatedOffset.generatedLine\n      ) {\n        generatedPosition.lastColumn =\n          nextSection.generatedOffset.generatedColumn - 2;\n      }\n      generatedPosition.line += lineShift;\n\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    if (!section) return [];\n\n    return section.consumer.allGeneratedPositionsFor(aArgs).map(\n      generatedPosition => {\n        const lineShift = section.generatedOffset.generatedLine - 1;\n        const columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (\n          generatedPosition.lastColumn === Infinity &&\n          nextSection &&\n          generatedPosition.line === nextSection.generatedOffset.generatedLine\n        ) {\n          generatedPosition.lastColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        generatedPosition.line += lineShift;\n\n        return generatedPosition;\n      }\n    );\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection =\n        index + 1 < this._sections.length\n          ? this._sections[index + 1]\n          : null;\n      const { generatedOffset } = section;\n\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n\n      section.consumer.eachMapping(function(mapping) {\n        if (mapping.generatedLine === 1) {\n          mapping.generatedColumn += columnShift;\n\n          if (typeof mapping.lastGeneratedColumn === \"number\") {\n            mapping.lastGeneratedColumn += columnShift;\n          }\n        }\n\n        if (\n          mapping.lastGeneratedColumn === Infinity &&\n          nextSection &&\n          mapping.generatedLine === nextSection.generatedOffset.generatedLine\n        ) {\n          mapping.lastGeneratedColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        mapping.generatedLine += lineShift;\n\n        aCallback.call(this, mapping);\n      }, aContext, aOrder);\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}