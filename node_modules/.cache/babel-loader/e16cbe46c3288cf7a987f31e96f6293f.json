{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.array.index-of.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.date.to-string.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.parse-int.js\");\n\nrequire(\"core-js/modules/es.string.from-code-point.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nvar _require = require(\"./infra\"),\n    isASCIIHex = _require.isASCIIHex;\n\nfunction strictlySplitByteSequence(buf, cp) {\n  var list = [];\n  var last = 0;\n  var i = buf.indexOf(cp);\n\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n\n  return list;\n}\n\nfunction replaceByteInByteSequence(buf, from, to) {\n  var i = buf.indexOf(from);\n\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n\n  return buf;\n}\n\nfunction percentEncode(c) {\n  var hex = c.toString(16).toUpperCase();\n\n  if (hex.length === 1) {\n    hex = \"0\" + hex;\n  }\n\n  return \"%\" + hex;\n}\n\nfunction percentDecode(input) {\n  var output = Buffer.alloc(input.byteLength);\n  var ptr = 0;\n\n  for (var i = 0; i < input.length; ++i) {\n    if (input[i] !== 37 || !isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2])) {\n      output[ptr++] = input[i];\n    } else {\n      output[ptr++] = parseInt(input.slice(i + 1, i + 3).toString(), 16);\n      i += 2;\n    }\n  }\n\n  return output.slice(0, ptr);\n}\n\nfunction _parseUrlencoded(input) {\n  var sequences = strictlySplitByteSequence(input, 38);\n  var output = [];\n\n  var _iterator = _createForOfIteratorHelper(sequences),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var bytes = _step.value;\n\n      if (bytes.length === 0) {\n        continue;\n      }\n\n      var name = void 0;\n      var value = void 0;\n      var indexOfEqual = bytes.indexOf(61);\n\n      if (indexOfEqual >= 0) {\n        name = bytes.slice(0, indexOfEqual);\n        value = bytes.slice(indexOfEqual + 1);\n      } else {\n        name = bytes;\n        value = Buffer.alloc(0);\n      }\n\n      name = replaceByteInByteSequence(Buffer.from(name), 43, 32);\n      value = replaceByteInByteSequence(Buffer.from(value), 43, 32);\n      output.push([percentDecode(name).toString(), percentDecode(value).toString()]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return output;\n}\n\nfunction serializeUrlencodedByte(input) {\n  var output = \"\";\n\n  var _iterator2 = _createForOfIteratorHelper(input),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _byte = _step2.value;\n\n      if (_byte === 32) {\n        output += \"+\";\n      } else if (_byte === 42 || _byte === 45 || _byte === 46 || _byte >= 48 && _byte <= 57 || _byte >= 65 && _byte <= 90 || _byte === 95 || _byte >= 97 && _byte <= 122) {\n        output += String.fromCodePoint(_byte);\n      } else {\n        output += percentEncode(_byte);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return output;\n}\n\nfunction serializeUrlencoded(tuples) {\n  var encodingOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var encoding = \"utf-8\";\n\n  if (encodingOverride !== undefined) {\n    encoding = encodingOverride;\n  }\n\n  var output = \"\";\n\n  var _iterator3 = _createForOfIteratorHelper(tuples.entries()),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n          i = _step3$value[0],\n          tuple = _step3$value[1];\n\n      // TODO: handle encoding override\n      var name = serializeUrlencodedByte(Buffer.from(tuple[0]));\n      var value = tuple[1];\n\n      if (tuple.length > 2 && tuple[2] !== undefined) {\n        if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n          value = encoding;\n        } else if (tuple[2] === \"file\") {\n          // value is a File object\n          value = value.name;\n        }\n      }\n\n      value = serializeUrlencodedByte(Buffer.from(value));\n\n      if (i !== 0) {\n        output += \"&\";\n      }\n\n      output += \"\".concat(name, \"=\").concat(value);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return output;\n}\n\nmodule.exports = {\n  percentEncode: percentEncode,\n  percentDecode: percentDecode,\n  // application/x-www-form-urlencoded string parser\n  parseUrlencoded: function parseUrlencoded(input) {\n    return _parseUrlencoded(Buffer.from(input));\n  },\n  // application/x-www-form-urlencoded serializer\n  serializeUrlencoded: serializeUrlencoded\n};","map":{"version":3,"names":["require","isASCIIHex","strictlySplitByteSequence","buf","cp","list","last","i","indexOf","push","slice","length","replaceByteInByteSequence","from","to","percentEncode","c","hex","toString","toUpperCase","percentDecode","input","output","Buffer","alloc","byteLength","ptr","parseInt","parseUrlencoded","sequences","bytes","name","value","indexOfEqual","serializeUrlencodedByte","byte","String","fromCodePoint","serializeUrlencoded","tuples","encodingOverride","undefined","encoding","entries","tuple","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/terser/node_modules/whatwg-url/lib/urlencoded.js"],"sourcesContent":["\"use strict\";\nconst { isASCIIHex } = require(\"./infra\");\n\nfunction strictlySplitByteSequence(buf, cp) {\n  const list = [];\n  let last = 0;\n  let i = buf.indexOf(cp);\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n  return list;\n}\n\nfunction replaceByteInByteSequence(buf, from, to) {\n  let i = buf.indexOf(from);\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n  return buf;\n}\n\nfunction percentEncode(c) {\n  let hex = c.toString(16).toUpperCase();\n  if (hex.length === 1) {\n    hex = \"0\" + hex;\n  }\n\n  return \"%\" + hex;\n}\n\nfunction percentDecode(input) {\n  const output = Buffer.alloc(input.byteLength);\n  let ptr = 0;\n  for (let i = 0; i < input.length; ++i) {\n    if (input[i] !== 37 || !isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2])) {\n      output[ptr++] = input[i];\n    } else {\n      output[ptr++] = parseInt(input.slice(i + 1, i + 3).toString(), 16);\n      i += 2;\n    }\n  }\n  return output.slice(0, ptr);\n}\n\nfunction parseUrlencoded(input) {\n  const sequences = strictlySplitByteSequence(input, 38);\n  const output = [];\n  for (const bytes of sequences) {\n    if (bytes.length === 0) {\n      continue;\n    }\n\n    let name;\n    let value;\n    const indexOfEqual = bytes.indexOf(61);\n\n    if (indexOfEqual >= 0) {\n      name = bytes.slice(0, indexOfEqual);\n      value = bytes.slice(indexOfEqual + 1);\n    } else {\n      name = bytes;\n      value = Buffer.alloc(0);\n    }\n\n    name = replaceByteInByteSequence(Buffer.from(name), 43, 32);\n    value = replaceByteInByteSequence(Buffer.from(value), 43, 32);\n\n    output.push([percentDecode(name).toString(), percentDecode(value).toString()]);\n  }\n  return output;\n}\n\nfunction serializeUrlencodedByte(input) {\n  let output = \"\";\n  for (const byte of input) {\n    if (byte === 32) {\n      output += \"+\";\n    } else if (byte === 42 ||\n               byte === 45 ||\n               byte === 46 ||\n               (byte >= 48 && byte <= 57) ||\n               (byte >= 65 && byte <= 90) ||\n               byte === 95 ||\n               (byte >= 97 && byte <= 122)) {\n      output += String.fromCodePoint(byte);\n    } else {\n      output += percentEncode(byte);\n    }\n  }\n  return output;\n}\n\nfunction serializeUrlencoded(tuples, encodingOverride = undefined) {\n  let encoding = \"utf-8\";\n  if (encodingOverride !== undefined) {\n    encoding = encodingOverride;\n  }\n\n  let output = \"\";\n  for (const [i, tuple] of tuples.entries()) {\n    // TODO: handle encoding override\n    const name = serializeUrlencodedByte(Buffer.from(tuple[0]));\n    let value = tuple[1];\n    if (tuple.length > 2 && tuple[2] !== undefined) {\n      if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n        value = encoding;\n      } else if (tuple[2] === \"file\") {\n        // value is a File object\n        value = value.name;\n      }\n    }\n    value = serializeUrlencodedByte(Buffer.from(value));\n    if (i !== 0) {\n      output += \"&\";\n    }\n    output += `${name}=${value}`;\n  }\n  return output;\n}\n\nmodule.exports = {\n  percentEncode,\n  percentDecode,\n\n  // application/x-www-form-urlencoded string parser\n  parseUrlencoded(input) {\n    return parseUrlencoded(Buffer.from(input));\n  },\n\n  // application/x-www-form-urlencoded serializer\n  serializeUrlencoded\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}