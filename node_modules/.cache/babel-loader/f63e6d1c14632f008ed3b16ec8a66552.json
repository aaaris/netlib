{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _typeof = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nvar _classCallCheck = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"D:/Work/Project/LMS/lms/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nrequire(\"core-js/modules/es.object.set-prototype-of.js\");\n\nvar util = require(\"util\");\n\nvar deprecateContext = util.deprecate(function () {}, \"Hook.context is deprecated and will be removed\");\n\nvar CALL_DELEGATE = function CALL_DELEGATE() {\n  this.call = this._createCall(\"sync\");\n  return this.call.apply(this, arguments);\n};\n\nvar CALL_ASYNC_DELEGATE = function CALL_ASYNC_DELEGATE() {\n  this.callAsync = this._createCall(\"async\");\n  return this.callAsync.apply(this, arguments);\n};\n\nvar PROMISE_DELEGATE = function PROMISE_DELEGATE() {\n  this.promise = this._createCall(\"promise\");\n  return this.promise.apply(this, arguments);\n};\n\nvar Hook = /*#__PURE__*/function () {\n  function Hook() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    _classCallCheck(this, Hook);\n\n    this._args = args;\n    this.name = name;\n    this.taps = [];\n    this.interceptors = [];\n    this._call = CALL_DELEGATE;\n    this.call = CALL_DELEGATE;\n    this._callAsync = CALL_ASYNC_DELEGATE;\n    this.callAsync = CALL_ASYNC_DELEGATE;\n    this._promise = PROMISE_DELEGATE;\n    this.promise = PROMISE_DELEGATE;\n    this._x = undefined;\n    this.compile = this.compile;\n    this.tap = this.tap;\n    this.tapAsync = this.tapAsync;\n    this.tapPromise = this.tapPromise;\n  }\n\n  _createClass(Hook, [{\n    key: \"compile\",\n    value: function compile(options) {\n      throw new Error(\"Abstract: should be overridden\");\n    }\n  }, {\n    key: \"_createCall\",\n    value: function _createCall(type) {\n      return this.compile({\n        taps: this.taps,\n        interceptors: this.interceptors,\n        args: this._args,\n        type: type\n      });\n    }\n  }, {\n    key: \"_tap\",\n    value: function _tap(type, options, fn) {\n      if (typeof options === \"string\") {\n        options = {\n          name: options.trim()\n        };\n      } else if (_typeof(options) !== \"object\" || options === null) {\n        throw new Error(\"Invalid tap options\");\n      }\n\n      if (typeof options.name !== \"string\" || options.name === \"\") {\n        throw new Error(\"Missing name for tap\");\n      }\n\n      if (typeof options.context !== \"undefined\") {\n        deprecateContext();\n      }\n\n      options = Object.assign({\n        type: type,\n        fn: fn\n      }, options);\n      options = this._runRegisterInterceptors(options);\n\n      this._insert(options);\n    }\n  }, {\n    key: \"tap\",\n    value: function tap(options, fn) {\n      this._tap(\"sync\", options, fn);\n    }\n  }, {\n    key: \"tapAsync\",\n    value: function tapAsync(options, fn) {\n      this._tap(\"async\", options, fn);\n    }\n  }, {\n    key: \"tapPromise\",\n    value: function tapPromise(options, fn) {\n      this._tap(\"promise\", options, fn);\n    }\n  }, {\n    key: \"_runRegisterInterceptors\",\n    value: function _runRegisterInterceptors(options) {\n      var _iterator = _createForOfIteratorHelper(this.interceptors),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var interceptor = _step.value;\n\n          if (interceptor.register) {\n            var newOptions = interceptor.register(options);\n\n            if (newOptions !== undefined) {\n              options = newOptions;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return options;\n    }\n  }, {\n    key: \"withOptions\",\n    value: function withOptions(options) {\n      var _this = this;\n\n      var mergeOptions = function mergeOptions(opt) {\n        return Object.assign({}, options, typeof opt === \"string\" ? {\n          name: opt\n        } : opt);\n      };\n\n      return {\n        name: this.name,\n        tap: function tap(opt, fn) {\n          return _this.tap(mergeOptions(opt), fn);\n        },\n        tapAsync: function tapAsync(opt, fn) {\n          return _this.tapAsync(mergeOptions(opt), fn);\n        },\n        tapPromise: function tapPromise(opt, fn) {\n          return _this.tapPromise(mergeOptions(opt), fn);\n        },\n        intercept: function intercept(interceptor) {\n          return _this.intercept(interceptor);\n        },\n        isUsed: function isUsed() {\n          return _this.isUsed();\n        },\n        withOptions: function withOptions(opt) {\n          return _this.withOptions(mergeOptions(opt));\n        }\n      };\n    }\n  }, {\n    key: \"isUsed\",\n    value: function isUsed() {\n      return this.taps.length > 0 || this.interceptors.length > 0;\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(interceptor) {\n      this._resetCompilation();\n\n      this.interceptors.push(Object.assign({}, interceptor));\n\n      if (interceptor.register) {\n        for (var i = 0; i < this.taps.length; i++) {\n          this.taps[i] = interceptor.register(this.taps[i]);\n        }\n      }\n    }\n  }, {\n    key: \"_resetCompilation\",\n    value: function _resetCompilation() {\n      this.call = this._call;\n      this.callAsync = this._callAsync;\n      this.promise = this._promise;\n    }\n  }, {\n    key: \"_insert\",\n    value: function _insert(item) {\n      this._resetCompilation();\n\n      var before;\n\n      if (typeof item.before === \"string\") {\n        before = new Set([item.before]);\n      } else if (Array.isArray(item.before)) {\n        before = new Set(item.before);\n      }\n\n      var stage = 0;\n\n      if (typeof item.stage === \"number\") {\n        stage = item.stage;\n      }\n\n      var i = this.taps.length;\n\n      while (i > 0) {\n        i--;\n        var x = this.taps[i];\n        this.taps[i + 1] = x;\n        var xStage = x.stage || 0;\n\n        if (before) {\n          if (before.has(x.name)) {\n            before[\"delete\"](x.name);\n            continue;\n          }\n\n          if (before.size > 0) {\n            continue;\n          }\n        }\n\n        if (xStage > stage) {\n          continue;\n        }\n\n        i++;\n        break;\n      }\n\n      this.taps[i] = item;\n    }\n  }]);\n\n  return Hook;\n}();\n\nObject.setPrototypeOf(Hook.prototype, null);\nmodule.exports = Hook;","map":{"version":3,"names":["util","require","deprecateContext","deprecate","CALL_DELEGATE","call","_createCall","CALL_ASYNC_DELEGATE","callAsync","PROMISE_DELEGATE","promise","Hook","args","name","undefined","_args","taps","interceptors","_call","_callAsync","_promise","_x","compile","tap","tapAsync","tapPromise","options","Error","type","fn","trim","context","Object","assign","_runRegisterInterceptors","_insert","_tap","interceptor","register","newOptions","mergeOptions","opt","intercept","isUsed","withOptions","length","_resetCompilation","push","i","item","before","Set","Array","isArray","stage","x","xStage","has","size","setPrototypeOf","prototype","module","exports"],"sources":["D:/Work/Project/LMS/lms/node_modules/tapable/lib/Hook.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst deprecateContext = util.deprecate(() => {},\n\"Hook.context is deprecated and will be removed\");\n\nconst CALL_DELEGATE = function(...args) {\n\tthis.call = this._createCall(\"sync\");\n\treturn this.call(...args);\n};\nconst CALL_ASYNC_DELEGATE = function(...args) {\n\tthis.callAsync = this._createCall(\"async\");\n\treturn this.callAsync(...args);\n};\nconst PROMISE_DELEGATE = function(...args) {\n\tthis.promise = this._createCall(\"promise\");\n\treturn this.promise(...args);\n};\n\nclass Hook {\n\tconstructor(args = [], name = undefined) {\n\t\tthis._args = args;\n\t\tthis.name = name;\n\t\tthis.taps = [];\n\t\tthis.interceptors = [];\n\t\tthis._call = CALL_DELEGATE;\n\t\tthis.call = CALL_DELEGATE;\n\t\tthis._callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis.callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis._promise = PROMISE_DELEGATE;\n\t\tthis.promise = PROMISE_DELEGATE;\n\t\tthis._x = undefined;\n\n\t\tthis.compile = this.compile;\n\t\tthis.tap = this.tap;\n\t\tthis.tapAsync = this.tapAsync;\n\t\tthis.tapPromise = this.tapPromise;\n\t}\n\n\tcompile(options) {\n\t\tthrow new Error(\"Abstract: should be overridden\");\n\t}\n\n\t_createCall(type) {\n\t\treturn this.compile({\n\t\t\ttaps: this.taps,\n\t\t\tinterceptors: this.interceptors,\n\t\t\targs: this._args,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\t_tap(type, options, fn) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = {\n\t\t\t\tname: options.trim()\n\t\t\t};\n\t\t} else if (typeof options !== \"object\" || options === null) {\n\t\t\tthrow new Error(\"Invalid tap options\");\n\t\t}\n\t\tif (typeof options.name !== \"string\" || options.name === \"\") {\n\t\t\tthrow new Error(\"Missing name for tap\");\n\t\t}\n\t\tif (typeof options.context !== \"undefined\") {\n\t\t\tdeprecateContext();\n\t\t}\n\t\toptions = Object.assign({ type, fn }, options);\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttap(options, fn) {\n\t\tthis._tap(\"sync\", options, fn);\n\t}\n\n\ttapAsync(options, fn) {\n\t\tthis._tap(\"async\", options, fn);\n\t}\n\n\ttapPromise(options, fn) {\n\t\tthis._tap(\"promise\", options, fn);\n\t}\n\n\t_runRegisterInterceptors(options) {\n\t\tfor (const interceptor of this.interceptors) {\n\t\t\tif (interceptor.register) {\n\t\t\t\tconst newOptions = interceptor.register(options);\n\t\t\t\tif (newOptions !== undefined) {\n\t\t\t\t\toptions = newOptions;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\twithOptions(options) {\n\t\tconst mergeOptions = opt =>\n\t\t\tObject.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\ttap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n\t\t\ttapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n\t\t\ttapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n\t\t\tintercept: interceptor => this.intercept(interceptor),\n\t\t\tisUsed: () => this.isUsed(),\n\t\t\twithOptions: opt => this.withOptions(mergeOptions(opt))\n\t\t};\n\t}\n\n\tisUsed() {\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._resetCompilation();\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\n\t\tif (interceptor.register) {\n\t\t\tfor (let i = 0; i < this.taps.length; i++) {\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t_resetCompilation() {\n\t\tthis.call = this._call;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis.promise = this._promise;\n\t}\n\n\t_insert(item) {\n\t\tthis._resetCompilation();\n\t\tlet before;\n\t\tif (typeof item.before === \"string\") {\n\t\t\tbefore = new Set([item.before]);\n\t\t} else if (Array.isArray(item.before)) {\n\t\t\tbefore = new Set(item.before);\n\t\t}\n\t\tlet stage = 0;\n\t\tif (typeof item.stage === \"number\") {\n\t\t\tstage = item.stage;\n\t\t}\n\t\tlet i = this.taps.length;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tconst x = this.taps[i];\n\t\t\tthis.taps[i + 1] = x;\n\t\t\tconst xStage = x.stage || 0;\n\t\t\tif (before) {\n\t\t\t\tif (before.has(x.name)) {\n\t\t\t\t\tbefore.delete(x.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (before.size > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xStage > stage) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tthis.taps[i] = item;\n\t}\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\n\nmodule.exports = Hook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}